

‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ .github
    ‚îú‚îÄ‚îÄ FUNDING.yml
    ‚îî‚îÄ‚îÄ workflows
    ‚îÇ   ‚îú‚îÄ‚îÄ docs.yml
    ‚îÇ   ‚îî‚îÄ‚îÄ test.yml
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ .size-limit.cjs
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ Makefile
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ assets
    ‚îú‚îÄ‚îÄ logo.png
    ‚îú‚îÄ‚îÄ logo_16x9.png
    ‚îî‚îÄ‚îÄ logo_square.png
‚îú‚îÄ‚îÄ examples
    ‚îú‚îÄ‚îÄ autoload.ts
    ‚îú‚îÄ‚îÄ benchmark-selectors.ts
    ‚îú‚îÄ‚îÄ bytecode.ts
    ‚îú‚îÄ‚îÄ dot.ts
    ‚îú‚îÄ‚îÄ index-interfaces.ts
    ‚îî‚îÄ‚îÄ resolveproxy.ts
‚îú‚îÄ‚îÄ flake.lock
‚îú‚îÄ‚îÄ flake.nix
‚îú‚îÄ‚îÄ funding.json
‚îú‚îÄ‚îÄ package.cjs.json
‚îú‚îÄ‚îÄ package.esm.json
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ pnpm-lock.yaml
‚îú‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ __tests__
    ‚îÇ   ‚îú‚îÄ‚îÄ __fixtures__
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ proxies.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sample.ts
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sample2.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ abi.test.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ auto.test.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ disasm.test.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ edges.test.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ env.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ examples.test.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ index.test.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ interfaces.test.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ loaders.test.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ providers.test.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ proxies.test.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ selectors.test.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ util.test.ts
    ‚îú‚îÄ‚îÄ _generated-interfaces.ts
    ‚îú‚îÄ‚îÄ abi.ts
    ‚îú‚îÄ‚îÄ auto.ts
    ‚îú‚îÄ‚îÄ disasm.ts
    ‚îú‚îÄ‚îÄ errors.ts
    ‚îú‚îÄ‚îÄ index.ts
    ‚îú‚îÄ‚îÄ interfaces.ts
    ‚îú‚îÄ‚îÄ internal
    ‚îÇ   ‚îú‚îÄ‚îÄ debug.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ filecache.ts
    ‚îú‚îÄ‚îÄ loaders.ts
    ‚îú‚îÄ‚îÄ opcodes.ts
    ‚îú‚îÄ‚îÄ providers.ts
    ‚îú‚îÄ‚îÄ proxies.ts
    ‚îú‚îÄ‚îÄ selectors.ts
    ‚îú‚îÄ‚îÄ slots.ts
    ‚îú‚îÄ‚îÄ utils.ts
    ‚îî‚îÄ‚îÄ whatsabi.ts
‚îú‚îÄ‚îÄ tsconfig.base.json
‚îú‚îÄ‚îÄ tsconfig.cjs.json
‚îú‚îÄ‚îÄ tsconfig.esm.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ tsconfig.types.json
‚îú‚îÄ‚îÄ typedoc.json
‚îî‚îÄ‚îÄ vite.config.ts


/.env.example:
--------------------------------------------------------------------------------
1 | # Save as .env, fill in keys, gets automatically sourced by `nix develop`
2 | export INFURA_API_KEY="..."
3 | export ETHERSCAN_API_KEY="..."
4 | export PROVIDER="ethers"  # or "viem"
5 | 
6 | # Use an arbitrary JSON RPC endpoint instead:
7 | #export PROVIDER_RPC_URL="https://ethereum-rpc.publicnode.com"
8 | 


--------------------------------------------------------------------------------
/.github/FUNDING.yml:
--------------------------------------------------------------------------------
 1 | # These are supported funding model platforms
 2 | 
 3 | github: [shazow]
 4 | patreon: # Replace with a single Patreon username
 5 | open_collective: # Replace with a single Open Collective username
 6 | ko_fi: # Replace with a single Ko-fi username
 7 | tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel
 8 | community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
 9 | liberapay: # Replace with a single Liberapay username
10 | issuehunt: # Replace with a single IssueHunt username
11 | otechie: # Replace with a single Otechie username
12 | lfx_crowdfunding: # Replace with a single LFX Crowdfunding project-name e.g., cloud-foundry
13 | custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']
14 | 


--------------------------------------------------------------------------------
/.github/workflows/docs.yml:
--------------------------------------------------------------------------------
 1 | name: Deploy docs
 2 | 
 3 | on:
 4 |   push:
 5 |     branches: [main]
 6 |   workflow_dispatch:
 7 | 
 8 | concurrency:
 9 |   group: "pages"
10 |   cancel-in-progress: false
11 | 
12 | # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
13 | permissions:
14 |   contents: read
15 |   pages: write
16 |   id-token: write
17 | 
18 | jobs:
19 |   build:
20 |     name: "Build TypeDocs"
21 |     runs-on: ubuntu-latest
22 |     steps:
23 |       - uses: actions/checkout@v4
24 |       - uses: pnpm/action-setup@v2
25 |         with:
26 |           version: 8
27 |       - uses: actions/setup-node@v3
28 |         with:
29 |           cache: pnpm
30 |       - run: pnpm install
31 |       - run: pnpm build:docs
32 |       - name: Upload artifact
33 |         uses: actions/upload-pages-artifact@v3
34 |         with:
35 |           path: ./docs
36 | 
37 |   deploy:
38 |     environment:
39 |       name: github-pages
40 |       url: ${{ steps.deployment.outputs.page_url }}
41 |     runs-on: ubuntu-latest
42 |     needs: build
43 |     steps:
44 |       - name: Deploy to GitHub Pages
45 |         id: deployment
46 |         uses: actions/deploy-pages@v4
47 | 


--------------------------------------------------------------------------------
/.github/workflows/test.yml:
--------------------------------------------------------------------------------
 1 | name: "Run Tests"
 2 | 
 3 | on:
 4 |   push:
 5 |     branches: ["main"]
 6 |   pull_request:
 7 |   workflow_dispatch:
 8 | 
 9 | jobs:
10 |   check:
11 |     name: "Project Tests"
12 |     runs-on: ubuntu-latest
13 |     strategy:
14 |       matrix:
15 |         provider: ["ethers", "viem", "web3"]
16 |     steps:
17 |       - uses: actions/checkout@v3
18 |       - uses: pnpm/action-setup@v2
19 |         with:
20 |           version: 8
21 |       - uses: actions/setup-node@v3
22 |         with:
23 |           cache: pnpm
24 |       - uses: actions/cache@v3
25 |         with:
26 |           key: api-result-cache
27 |           path: ./.cache
28 |       - run: pnpm install
29 |       - name: Run tests with ${{ matrix.provider }}
30 |         run: pnpm test
31 |         env:
32 |           PROVIDER: ${{ matrix.provider }}
33 |           ONLINE: 1
34 |           INFURA_API_KEY: ${{ secrets.INFURA_API_KEY }}
35 |           ETHERSCAN_API_KEY: ${{ secrets.ETHERSCAN_API_KEY }}
36 | 


--------------------------------------------------------------------------------
/.gitignore:
--------------------------------------------------------------------------------
1 | /node_modules/
2 | /.*
3 | /lib
4 | /lib.*
5 | /*.tgz
6 | /docs
7 | 


--------------------------------------------------------------------------------
/.size-limit.cjs:
--------------------------------------------------------------------------------
 1 | module.exports = [
 2 |   {
 3 |     path: "lib.esm/index.js",
 4 |     import: "{ whatsabi }",
 5 |     limit: "20 kb"
 6 |   },
 7 |   {
 8 |     path: "lib.cjs/index.js",
 9 |     import: "{ whatsabi }",
10 |     limit: "165 kb"
11 |   }
12 | ]
13 | 


--------------------------------------------------------------------------------
/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2022 Andrey Petrov
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/Makefile:
--------------------------------------------------------------------------------
 1 | build:
 2 | 	tsc --project tsconfig.esm.json
 3 | 
 4 | docs:
 5 | 	pnpm build:docs
 6 | 
 7 | serve-docs:
 8 | 	python -m http.server -d ./docs
 9 | 
10 | watch:
11 | 	tsc --project tsconfig.esm.json -w
12 | 
13 | test:
14 | 	vitest run
15 | 
16 | test-providers:
17 | 	# Might want to also do ONLINE=1 when running this
18 | 	PROVIDER=ethers vitest run
19 | 	PROVIDER=web3 vitest run
20 | 	PROVIDER=viem vitest run
21 | 	PROVIDER=viem:transport vitest run
22 | 	PROVIDER=viem:publicClient vitest run
23 | 
24 | clean:
25 | 	rm -rf ./lib ./lib.*
26 | 
27 | publish: clean
28 | 	pnpm i
29 | 	pnpm run build:esm
30 | 	pnpm run build:cjs
31 | 	pnpm run build:types
32 | 	pnpm pack
33 | 	size-limit
34 | 
35 | run-examples:
36 | 	./examples/autoload.ts $(ADDRESS)
37 | 	./examples/bytecode.ts $(ADDRESS)
38 | 	./examples/dot.ts $(ADDRESS)
39 | 	./examples/resolveproxy.ts $(ADDRESS)
40 | 
41 | ./src/_generated-interfaces.ts: ./examples/index-interfaces.ts
42 | 	# Has to be done in two steps because of circular import
43 | 	

lt; > $@_
44 | 	mv $@_ $@
45 | 
46 | generated: ./src/_generated-interfaces.ts
47 | 
48 | .PHONY: docs
49 | 


--------------------------------------------------------------------------------
/README.md:
--------------------------------------------------------------------------------
  1 | ![WhatsABI](assets/logo.png)
  2 | 
  3 | # WhatsABI
  4 | 
  5 | Guess an ABI and detect proxies from an Ethereum bytecode, even if it's unverified.
  6 | 
  7 | WhatsABI is perfect for building procedural frontends, embedding in wallets, block explorers, or doing bytecode analysis.
  8 | 
  9 | ü§ù Used by **Otterscan, Sourcify, Ondora, Rivet,** [and more great projects](#projects-powered-by-whatsabi).
 10 | 
 11 | ## Features
 12 | 
 13 | **What can WhatsABI do**?
 14 | - Return selectors from bytecode.
 15 | - Look up function signatures from selectors.
 16 | - Helpers for looking up ABI and signatures from public databases (like Sourcify, Etherscan, Blockscout, OpenChain, 4Byte).
 17 | - ‚ú® Resolve proxy contracts!
 18 | - Small bundle (less than 15 KB) that works with Ethers.js, Viem, and others.
 19 | 
 20 | **WhatsABI is different from other EVM analysis tools in some important ways:**
 21 | - Built in Typescript with minimal dependencies, so that it is **runnable in the browser and embeddable in wallets.**
 22 | - Algorithms used are limited to `O(instructions)` with a small constant factor, so that **complex contracts don't cause it to time out or use unbounded memory.**
 23 | - Does not rely on source code, so it **works with unverified contracts.**
 24 | - Does not assume the source language, so it can work for source languages other than Solidity (Vyper, or even hand-written assembly).
 25 | - Permissive open source (MIT-licensed), so that anyone can use it.
 26 | 
 27 | ## Usage
 28 | 
 29 | Generated docs: https://shazow.github.io/whatsabi/
 30 | 
 31 | Quick start:
 32 | 
 33 | ```typescript
 34 | import { ethers } from "ethers";
 35 | import { whatsabi } from "@shazow/whatsabi";
 36 | 
 37 | // Works with any provider (or client) library like Ethers.js, Viem, or Web3.js!
 38 | const provider = ethers.getDefaultProvider();
 39 | const address = "0x00000000006c3852cbEf3e08E8dF289169EdE581"; // Or your fav contract address
 40 | 
 41 | // Quick-start:
 42 | 
 43 | const result = await whatsabi.autoload(address, { provider });
 44 | console.log(result.abi);
 45 | // -> [ ... ]
 46 | ```
 47 | 
 48 | Another quick example with Viem:
 49 | 
 50 | ```typescript
 51 | import { createPublicClient, http } from 'viem'
 52 | import { mainnet } from 'viem/chains'
 53 | import { whatsabi } from "@shazow/whatsabi";
 54 |  
 55 | const client = createPublicClient({ chain: mainnet, transport: http() })
 56 | const result = await whatsabi.autoload(address, { provider: client });
 57 | ```
 58 | 
 59 | 
 60 | Breaking it down, here's what autoload is doing on the inside:
 61 | 
 62 | ```typescript
 63 | const code = await provider.getCode(address); // Load the bytecode
 64 | 
 65 | // Get just the callable selectors
 66 | const selectors = whatsabi.selectorsFromBytecode(code);
 67 | console.log(selectors); // -> ["0x06fdde03", "0x46423aa7", "0x55944a42", ...]
 68 | 
 69 | // Get an ABI-like list of interfaces
 70 | const abi = whatsabi.abiFromBytecode(code);
 71 | console.log(abi);
 72 | // -> [
 73 | //  {"type": "event", "hash": "0x721c20121297512b72821b97f5326877ea8ecf4bb9948fea5bfcb6453074d37f"},
 74 | //  {"type": "function", "payable": true, "selector": "0x06fdde03", ...},
 75 | //  {"type": "function", "payable": true, "selector": "0x46423aa7", ...},
 76 | //   ...
 77 | 
 78 | // We also have a suite of database loaders for convenience
 79 | const signatureLookup = new whatsabi.loaders.OpenChainSignatureLookup();
 80 | console.log(await signatureLookup.loadFunctions("0x06fdde03"));
 81 | // -> ["name()"]);
 82 | console.log(await signatureLookup.loadFunctions("0x46423aa7"));
 83 | // -> ["getOrderStatus(bytes32)"]);
 84 | 
 85 | // We also have event loaders!
 86 | console.log(await signatureLookup.loadEvents("0x721c20121297512b72821b97f5326877ea8ecf4bb9948fea5bfcb6453074d37f"));
 87 | // -> ["CounterIncremented(uint256,address)"]
 88 | 
 89 | // There are more fancy loaders in whatsabi.loaders.*, take a look!
 90 | 
 91 | // Here's a multiloader with an Etherscan API key, it can be used with autoload below.
 92 | // Each source will be attempted until a result is found.
 93 | const loader = new whatsabi.loaders.MultiABILoader([
 94 |   new whatsabi.loaders.SourcifyABILoader(),
 95 |   new whatsabi.loaders.EtherscanABILoader({
 96 |     apiKey: "...", // Replace the value with your Etherscan API key
 97 |   }),
 98 |   new whatsabi.loaders.BlockscoutABILoader({
 99 |     apiKey: "...", // Replace the value with your Blockscout API key
100 |   }),
101 | ]);
102 | const { abi, name, /* ... other metadata */ } = await loader.getContract(address));
103 | ```
104 | 
105 | See [whatsabi.loaders](https://shazow.github.io/whatsabi/modules/whatsabi.loaders.html) for more examples of what our loaders can do, like loading verified contract source code and compiler settings.
106 | 
107 | All together with our do-all-the-things helper:
108 | 
109 | ```typescript
110 | ...
111 | 
112 | let result = await whatsabi.autoload(address, {
113 |   provider: provider,
114 | 
115 |   // * Optional loaders:
116 |   // abiLoader: whatsabi.loaders.defaultABILoader,
117 |   // signatureLoader: whatsabi.loaders.defaultSignatureLookup,
118 | 
119 |   // There is a handy helper for adding the default loaders but with your own settings
120 |   ... whatsabi.loaders.defaultsWithEnv({
121 |     SOURCIFY_CHAIN_ID: 42161,
122 |     ETHERSCAN_BASE_URL: "https://api.arbiscan.io/api",
123 |     ETHERSCAN_API_KEY: "MYSECRETAPIKEY",
124 |   }),
125 | 
126 |   // * Optional hooks:
127 |   // onProgress: (phase: string) => { ... }
128 |   // onError: (phase: string, context: any) => { ... }
129 | 
130 |   onProgress: (phase) => console.log("autoload progress", phase),
131 |   onError: (phase, context) => console.log("autoload error", phase, context),
132 | 
133 |   // * Optional overrides:
134 |   // addressResolver: (name: string) => Promise<string>
135 | 
136 |   // * Optional settings:
137 |   // followProxies: false,
138 |   // enableExperimentalMetadata: false,
139 | });
140 | 
141 | console.log(result.abi);
142 | 
143 | // Detail will vary depending on whether `address` source code was available,
144 | // or if bytecode-loaded selector signatures were available, or
145 | // if WhatsABI had to guess everything from just bytecode.
146 | 
147 | // We can even detect and resolve proxies!
148 | if (result.followProxies) {
149 |     console.log("Proxies detected:", result.proxies);
150 | 
151 |     result = await result.followProxies();
152 |     console.log(result.abi);
153 | }
154 | ```
155 | 
156 | Or we can auto-follow resolved proxies, and expand parts of the result object:
157 | 
158 | ```typescript
159 | const { abi, address } = await whatsabi.autoload(
160 |     "0x4f8AD938eBA0CD19155a835f617317a6E788c868",
161 |     {
162 |         provider,
163 |         followProxies: true,
164 |     },
165 | });
166 | 
167 | console.log("Resolved to:", address);
168 | // -> "0x964f84048f0d9bb24b82413413299c0a1d61ea9f"
169 | ```
170 | 
171 | 
172 | ## See Also
173 | 
174 | ### Projects powered by WhatsABI
175 | 
176 | * ‚≠ê [otterscan.io](https://otterscan.io/) - Open source block explorer, [contract interactions powered by WhatsABI](https://x.com/otterscan/status/1817261257994756569)
177 | * ‚≠ê [sourcify.dev](https://sourcify.dev/) - Verified source code API, proxy resolving powered by WhatsABI
178 | * ‚≠ê [rivet](https://github.com/paradigmxyz/rivet) - Developer Wallet & DevTools for Anvil
179 | * ‚≠ê [ondora.xyz](https://www.ondora.xyz/) - Cross-chain explorer and search engine
180 | * ‚≠ê [thirdweb](https://thirdweb.com/) - Web3 SDK, automatic ABI Resolution powered by WhatsABI
181 | * [callthis.link](https://callthis.link/) - Transaction builder powered by WhatsABI
182 | * [abi.w1nt3r.xyz](https://abi.w1nt3r.xyz/) - A frontend for whatsabi by [@w1nt3r_eth](https://twitter.com/w1nt3r_eth)
183 | * [ethcmd.com](https://www.ethcmd.com/) - Contract explorer frontend, [uses whatsabi for unverified contracts](https://github.com/verynifty/ethcmd)
184 | * [monobase.xyz](https://monobase.xyz) - Universal frontend, [uses whatsabi for unverified contracts](https://twitter.com/nazar_ilamanov/status/1659648915195707392)
185 | * [savvy](https://svvy.sh/) - Contract explorer with in-browser devnet execution
186 | * [blockscout](https://www.blockscout.com/) - Open source block explorer
187 | * [curvegrid](https://www.curvegrid.com/) - Platform for building EVM applications
188 | * [tevm](https://tevm.sh/) - EVM toolkit for TypeScript
189 | 
190 | ### Talks & Presentations
191 | 
192 | * [The Bytecode with Shafu - WhatsABI](https://www.youtube.com/watch?v=Io8bcYFjoEE) (July 2024)
193 | * [WhatsABI? - Seminar for Spearbit](https://www.youtube.com/watch?v=sfgassm8SKw) (April 2023)
194 | 
195 | ## Some Cool People Said...
196 | 
197 | > Omg WhatsABI by @shazow is so good that it can solve CTFs.  
198 | > In one of my CTFs, students are supposed to find calldata that doesn‚Äôt revert  
199 | > WhatsABI just spits out the solution automaticallyüòÇ I‚Äôm impressed!üëè
200 | >  
201 | > üó£Ô∏è [Nazar Ilamanov](https://twitter.com/nazar_ilamanov/status/1661240265955495936), creator of [monobase.xyz](https://monobase.xyz/)
202 | 
203 | > WhatsABI by @shazow takes contract bytecode, disassembled it into a set of EVM instructions, and then looks for the common Solidity's dispatch pattern.  
204 | > Check out the source, it's actually very elegant!
205 | >  
206 | > üó£Ô∏è [WINTŒûR](https://twitter.com/w1nt3r_eth/status/1575848038223921152), creator of [abi.w1nt3r.xyz](https://abi.w1nt3r.xyz/)
207 | 
208 | > really cool stuff from @shazow  
209 | > deduce a contract's ABI purely from bytecode
210 | >  
211 | > üó£Ô∏è [t11s](https://twitter.com/transmissions11/status/1574851435971215360), from Paradigm
212 | 
213 | ## Caveats
214 | 
215 | * If the contract is verified, `autoload` will just fetch the registered ABI and everything should be perfect either way.
216 | * Finding valid function selectors from bytecode works great!
217 | * Detecting Solidity-style function modifiers (view, payable, etc) is still unreliable.
218 | * There's some minimal attempts at guessing the presence of arguments, but also unreliable.
219 | * Call graph traversal only supports static jumps right now. Dynamic jumps are skipped until we add abstract stack tracing, this is the main cause of above's unreliability.
220 | * Event parsing is janky, haven't found a reliable pattern so assume it's best
221 |   effort. Feel free to open an issue with good failure examples, especially
222 |   false negatives.
223 | 
224 | ## Development
225 | 
226 | ```console
227 | $ cat .env  # Write an .env file with your keys, or `cp .env.example .env`
228 | export INFURA_API_KEY="..."
229 | export ETHERSCAN_API_KEY="..."
230 | export BLOCKSCOUT_API_KEY="..."
231 | $ nix develop  # Or use your system's package manager to install node/ts/etc
232 | [dev] $ npm install
233 | [dev] $ ONLINE=1 make test
234 | ```
235 | 
236 | 
237 | ## Thanks
238 | 
239 | * ‚≠ê [Herd Labs](https://www.herd.eco/) for sponsoring WhatsABI.
240 | * [ethers.js](https://github.com/ethers-io/ethers.js/) for being excellent, and
241 |   having a helpful assembler sub-package was inspiring.
242 | * [@jacobdehart](https://twitter.com/jacobdehart) for the library name and logo
243 |   that is totally a wasabi and not a green poop!
244 | * [Etherscan](https://etherscan.io/) for increasing our API limits.
245 | 
246 | 
247 | ## License
248 | 
249 | MIT
250 | 


--------------------------------------------------------------------------------
/assets/logo.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/shazow/whatsabi/60c76be67a864821a28c593c316448370d66702c/assets/logo.png


--------------------------------------------------------------------------------
/assets/logo_16x9.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/shazow/whatsabi/60c76be67a864821a28c593c316448370d66702c/assets/logo_16x9.png


--------------------------------------------------------------------------------
/assets/logo_square.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/shazow/whatsabi/60c76be67a864821a28c593c316448370d66702c/assets/logo_square.png


--------------------------------------------------------------------------------
/examples/autoload.ts:
--------------------------------------------------------------------------------
 1 | #!/usr/bin/env -S tsx
 2 | 
 3 | import { ethers } from "ethers";
 4 | import { whatsabi } from "../src/index.js";
 5 | 
 6 | const env = {
 7 |     INFURA_API_KEY: process.env.INFURA_API_KEY,
 8 |     ETHERSCAN_API_KEY: process.env.ETHERSCAN_API_KEY,
 9 |     PROVIDER: process.env.PROVIDER,
10 |     NETWORK: process.env.NETWORK,
11 |     SKIP_LOOKUPS: process.env.SKIP_LOOKUPS,
12 | };
13 | const provider = env.INFURA_API_KEY ? (new ethers.InfuraProvider("homestead", env.INFURA_API_KEY)) : ethers.getDefaultProvider(env.NETWORK || "homestead");
14 | 
15 | // Helper
16 | // https://stackoverflow.com/questions/11731072/dividing-an-array-by-filter-function 
17 | const partitionBy = <T>(
18 |   arr: T[],
19 |   predicate: (v: T, i: number, ar: T[]) => boolean
20 | ) =>
21 |   arr.reduce(
22 |     (acc, item, index, array) => {
23 |       acc[+!predicate(item, index, array)].push(item);
24 |       return acc;
25 |     },
26 |     [[], []] as [T[], T[]]
27 |   );
28 | 
29 | async function main() {
30 |     const address = process.env["ADDRESS"] || process.argv[2];
31 | 
32 |     if (!address) {
33 |         console.log("Usage: autoload.ts ADDRESS");
34 |         process.exit(1);
35 |     }
36 | 
37 |     let extraConfig : object = whatsabi.loaders.defaultsWithEnv(env);
38 |     if (env.SKIP_LOOKUPS) {
39 |         console.debug("Skipping lookups, only using bytecode");
40 |         extraConfig = {
41 |             abiLoader: false,
42 |             signatureLookup: false,
43 |         };
44 |     }
45 | 
46 |     let r = await whatsabi.autoload(address, {
47 |         provider,
48 |         onProgress: (phase: string, ...args: string[]) => {
49 |             console.debug("progress:", phase, ...args);
50 |         },
51 |         ... extraConfig
52 |     });
53 | 
54 |     while (true) {
55 |         const [abi, unresolved] = partitionBy(r.abi, a => (a.type !== "function" || "name" in a));
56 |         const iface = new ethers.Interface(abi);
57 |         console.log("autoload", iface.format());
58 |         if (unresolved) console.log("unresolved", unresolved);
59 |         const detectedInterfaces = whatsabi.interfaces.abiToInterfaces(abi);
60 |         if (detectedInterfaces.length) console.log("detected interfaces:", detectedInterfaces);
61 | 
62 |         if (!r.followProxies) {
63 |             if (r.proxies.length) {
64 |                 console.log("proxies detected but not following:", r.proxies);
65 |             }
66 |             break;
67 |         }
68 | 
69 |         console.log("following proxies...");
70 |         r = await r.followProxies();
71 |     }
72 | }
73 | 
74 | main().then().catch(err => {
75 |     console.error("Failed:", err)
76 |     process.exit(2);
77 | })
78 | 


--------------------------------------------------------------------------------
/examples/benchmark-selectors.ts:
--------------------------------------------------------------------------------
 1 | #!/usr/bin/env -S tsx
 2 | // Read JSON blobs line-by-line, containing keys `code` and `abi`, compare results
 3 | 
 4 | import { ethers } from "ethers";
 5 | import { whatsabi } from "../src/index.js";
 6 | 
 7 | import readline from "readline";
 8 | 
 9 | main().then().catch(err => {
10 |     console.error("Failed:", err)
11 |     process.exit(2);
12 | })
13 | 
14 | async function main() {
15 |     const pipe = readline.createInterface({
16 |       input: process.stdin,
17 |       terminal: false
18 |     });
19 | 
20 |     const result = {
21 |         elapsed: 0, // in ms
22 |         count: 0,
23 |         falsePositive: 0,
24 |         falseNegative: 0,
25 |     };
26 | 
27 |     pipe.on('line', (line) => {
28 |         let data: any;
29 |         try {
30 |             data = JSON.parse(line);
31 |         } catch (error) {
32 |             console.error("Failed to parse line:", error);
33 |             return;
34 |         }
35 | 
36 |         // Measure time spent in whatsabi
37 |         const start = new Date();
38 |         const selectors = whatsabi.selectorsFromBytecode(data.code);
39 |         const end = new Date();
40 | 
41 |         // Compare results
42 |         const want = new Set<string>();
43 |         const sigs: Record<string, string> = {};
44 |         ethers.Interface.from(data.abi).forEachFunction((fragment) => {
45 |             want.add(fragment.selector);
46 |             sigs[fragment.selector] = fragment.format();
47 |         });
48 |         const got = new Set<string>(selectors);
49 | 
50 |         const falsePositive = [...got].filter(x => !want.has(x));
51 |         const falseNegative = [...want].filter(x => !got.has(x));
52 | 
53 |         result.elapsed += end.getTime() - start.getTime();
54 |         result.count += 1;
55 |         result.falsePositive += falsePositive.length;
56 |         result.falseNegative += falseNegative.length;
57 | 
58 |         if (falsePositive.length > 0 || falseNegative.length > 0) {
59 |             console.error({
60 |                 address: data.address,
61 |                 id: result.count,
62 |                 falsePositive: falsePositive.map(s => { return {selector: s, signature: sigs[s] }}),
63 |                 falseNegative: falseNegative.map(s => { return {selector: s, signature: sigs[s] }}),
64 |             });
65 |         }
66 | 
67 |     });
68 | 
69 |     pipe.once('close', () => {
70 |         console.log(result);
71 |     });
72 | 
73 | };
74 | 


--------------------------------------------------------------------------------
/examples/bytecode.ts:
--------------------------------------------------------------------------------
 1 | #!/usr/bin/env -S tsx
 2 | 
 3 | import { ethers } from "ethers";
 4 | import { readFileSync } from "fs";
 5 | 
 6 | import { withCache } from "../src/internal/filecache.js";
 7 | import { bytecodeToString } from '../src/internal/debug.js';
 8 | import type { bytecodeToStringConfig } from '../src/internal/debug.js';
 9 | 
10 | const { INFURA_API_KEY, OPCODES_JSON } = process.env;
11 | const provider = INFURA_API_KEY ? (new ethers.InfuraProvider("homestead", INFURA_API_KEY)) : ethers.getDefaultProvider("homestead");
12 | 
13 | async function main() {
14 |     const address = process.env["ADDRESS"] || process.argv[2];
15 |     const jumpdest = process.env["JUMPDEST"] || process.argv[3];
16 |     const boundary = process.env["BOUNDARY"] || process.argv[4];
17 | 
18 |     let code : string;
19 |     if (!address) {
20 |         console.error("Invalid address: " + address);
21 |         process.exit(1);
22 |     } else if (address === "-") {
23 |         // Read contract code from stdin
24 |         code = readFileSync(0, 'utf8').trim();
25 |     } else {
26 |         console.debug("Loading code for address:", address);
27 |         code = await withCache(
28 |             `${address}_abi`,
29 |             async () => {
30 |                 return await provider.getCode(address)
31 |             },
32 |         );
33 |     }
34 | 
35 |     const config : bytecodeToStringConfig = {};
36 | 
37 |     if (OPCODES_JSON) {
38 |         const opcodes = JSON.parse(readFileSync(OPCODES_JSON, 'utf8'));
39 | 
40 |         config.opcodeLookup = Object.fromEntries(
41 |             Object.entries(opcodes).map(([k, v]) => [parseInt(k, 16), v as string])
42 |         );
43 |     }
44 |     if (jumpdest) {
45 |         const pos = jumpdest.startsWith("0x") ? parseInt(jumpdest, 16) : parseInt(jumpdest); 
46 |         config.startPos = config.highlightPos = pos;
47 |         config.stopPos = pos + 40;
48 |     }
49 |     if (boundary) {
50 |         config.boundaryPos = Number(boundary);
51 |     }
52 | 
53 |     const iter = bytecodeToString(code, config);
54 |     while (true) {
55 |         const {value, done} = iter.next()
56 |         if (done) break;
57 |         console.log(value);
58 |     }
59 | }
60 | 
61 | main().then().catch(err => {
62 |     console.error("Failed:", err)
63 |     process.exit(2);
64 | })
65 | 


--------------------------------------------------------------------------------
/examples/dot.ts:
--------------------------------------------------------------------------------
  1 | #!/usr/bin/env -S tsx
  2 | 
  3 | // Example usage:
  4 | // ./examples/dot.ts 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | dot -Tpng  | feh -
  5 | 
  6 | import { ethers } from "ethers";
  7 | import { readFileSync } from "fs";
  8 | 
  9 | import { withCache } from "../src/internal/filecache.js";
 10 | import { Program, Function } from "../src/disasm.js";
 11 | import { disasm } from '../src/disasm.js';
 12 | import { mnemonics } from "../src/opcodes.js";
 13 | import { defaultSignatureLookup } from "../src/loaders.js";
 14 | import { bytesToHex } from "../src/utils.js";
 15 | 
 16 | const { INFURA_API_KEY, SKIP_SELECTOR_LOOKUP, SKIP_TAGS } = process.env;
 17 | const provider = INFURA_API_KEY ? (new ethers.InfuraProvider("homestead", INFURA_API_KEY)) : ethers.getDefaultProvider("homestead");
 18 | 
 19 | 
 20 | export function* programToDotGraph(p: Program, lookup: { [key: string]: string }) {
 21 |     yield "digraph JUMPS {";
 22 |     yield "\tgraph [nojustify=true];\n";
 23 |     yield "\tnode [shape=record];\n";
 24 | 
 25 |     const nameLookup = Object.fromEntries(Object.entries(p.selectors).map(([k, v]) => [v, k]));
 26 | 
 27 |     function toID(n: number): string {
 28 |         return (nameLookup[n] || bytesToHex(n));
 29 |     }
 30 |     yield "\tsubgraph cluster_0 {"
 31 |     yield "\t\tlabel = Selectors;";
 32 |     yield "\t\tnode [style=filled];";
 33 |     yield "\t\trankdir=LR;";
 34 |     yield `\t\t${Object.keys(p.selectors).map(s => '"' + s + '"').join(" ")}`
 35 |     yield "\t}"
 36 | 
 37 |     const jumps: Function[] = Object.values(p.selectors).map(j => p.dests[j]) as Function[];
 38 |     const seen = new Set<number>();
 39 | 
 40 |     if (jumps.length == 0) jumps.push(...Object.values(p.dests));
 41 | 
 42 |     while (jumps.length > 0) {
 43 |         const fn = jumps.pop();
 44 |         if (!fn) continue;
 45 |         if (seen.has(fn.start)) continue;
 46 | 
 47 |         seen.add(fn.start);
 48 |         const j = fn.jumps.filter(j => j in p.dests).map(j => p.dests[j]);
 49 |         const id = toID(fn.start);
 50 |         const parts = [id];
 51 |         const tags = fn.opTags && Array.from(fn.opTags).map(op => mnemonics[op]).join("\\l")
 52 |         const lookupExtra = lookup[id];
 53 |         if (lookupExtra) parts.push(lookupExtra);
 54 |         if (!SKIP_TAGS) parts.push(tags);
 55 | 
 56 |         yield `\t"${id}" [label="{` + parts.join(" | ") + `} }"]`;
 57 |         yield `\t"${id}" -> { ${j.map(n => '"' + toID(n.start) + '"').join(" ")} }`;
 58 | 
 59 |         jumps.push(...j);
 60 |     }
 61 | 
 62 |     yield "}";
 63 | }
 64 | 
 65 | 
 66 | async function main() {
 67 |     const address = process.env["ADDRESS"] || process.argv[2];
 68 | 
 69 |     let code : string;
 70 |     if (!address) {
 71 |         console.error("Invalid address: " + address);
 72 |         process.exit(1);
 73 |     } else if (address === "-") {
 74 |         // Read contract code from stdin
 75 |         code = readFileSync(0, 'utf8').trim();
 76 |     } else {
 77 |         code = await withCache(
 78 |             `${address}_abi`,
 79 |             async () => {
 80 |                 return await provider.getCode(address)
 81 |             },
 82 |         );
 83 |     }
 84 | 
 85 |     const program = disasm(code);
 86 | 
 87 |     const selectors : Array<string> = Object.keys(program.selectors);
 88 |     const lookup : { [key: string]: string }= {};
 89 |     for (const sel of selectors) {
 90 |         if (SKIP_SELECTOR_LOOKUP) break;
 91 | 
 92 |         const sigs = await withCache(
 93 |             `${sel}_selector`,
 94 |             async () => {
 95 |                 return await defaultSignatureLookup.loadFunctions(sel);
 96 |             },
 97 |         );
 98 |         if (sigs.length === 0) continue;
 99 |         lookup[sel] = sigs[0].split("(")[0];
100 |     }
101 | 
102 |     const iter = programToDotGraph(program, lookup);
103 | 
104 |     while (true) {
105 |         const {value, done} = iter.next()
106 |         if (done) break;
107 |         console.log(value);
108 |     }
109 | }
110 | 
111 | main().then().catch(err => {
112 |     console.error("Failed:", err)
113 |     process.exit(2);
114 | })
115 | 


--------------------------------------------------------------------------------
/examples/index-interfaces.ts:
--------------------------------------------------------------------------------
 1 | #!/usr/bin/env -S tsx
 2 | // Return an IndexedInterfaces object of known interfaces.
 3 | // This is hard-coded for now, we can make it pull in from other sources later.
 4 | 
 5 | import { whatsabi } from "../src/index.js";
 6 | import type { KnownInterfaces } from "../src/whatsabi.js";
 7 | 
 8 | const interfaces : KnownInterfaces = {
 9 |     "ERC-20": [
10 |         "function totalSupply() view returns (uint256)",
11 |         "function balanceOf(address) view returns (uint256)",
12 |         "function transfer(address, uint256) returns (bool)",
13 |         "function allowance(address, address) returns (uint256)",
14 |         "function approve(address, uint256) returns (bool)",
15 |         "function transferFrom(address, address, uint256) returns (bool)",
16 |     ],
17 |     "ERC-165": [
18 |         "function supportsInterface(bytes4 interfaceId) view returns (bool)",
19 |     ],
20 |     "ERC-721": [
21 |         "function balanceOf(address owner) view returns (uint256 balance)",
22 |         "function ownerOf(uint256 tokenId) view returns (address owner)",
23 |         "function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)",
24 |         "function safeTransferFrom(address from, address to, uint256 tokenId)",
25 |         "function transferFrom(address from, address to, uint256 tokenId)",
26 |         "function approve(address to, uint256 tokenId)",
27 |         "function setApprovalForAll(address operator, bool _approved)",
28 |         "function getApproved(uint256 tokenId) view returns (address operator)",
29 |         "function isApprovedForAll(address owner, address operator) view returns (bool)",
30 |     ],
31 |     "ERC-777": [
32 |         "function name() view returns (string memory)",
33 |         "function symbol() view returns (string memory)",
34 |         "function granularity() view returns (uint256)",
35 |         "function totalSupply() view returns (uint256)",
36 |         "function balanceOf(address owner) view returns (uint256)",
37 |         "function send(address recipient, uint256 amount, bytes calldata data)",
38 |         "function burn(uint256 amount, bytes calldata data)",
39 |         "function isOperatorFor(address operator, address tokenHolder) view returns (bool)",
40 |         "function authorizeOperator(address operator)",
41 |         "function revokeOperator(address operator)",
42 |         "function defaultOperators() view returns (address[] memory)",
43 |         "function operatorSend(address sender, address recipient, uint256 amount, bytes calldata data, bytes calldata operatorData)",
44 |         "function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData)",
45 |     ],
46 |     "ERC-1155": [
47 |         "function balanceOf(address account, uint256 id) view returns (uint256)",
48 |         "function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) view returns (uint256[] memory)",
49 |         "function setApprovalForAll(address operator, bool approved)",
50 |         "function isApprovedForAll(address account, address operator) view returns (bool)",
51 |         "function safeTransferFrom( address from, address to, uint256 id, uint256 amount, bytes calldata data)",
52 |         "function safeBatchTransferFrom( address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data)",
53 |     ],
54 |     "ERC-4626": [
55 |     ],
56 |     "Ownable": [
57 |         "function owner() view returns (address)",
58 |         "function renounceOwnership()",
59 |         "function transferOwnership(address)",
60 |     ],
61 |     "Multicall": [
62 |         "function multicall(bytes[]) returns (bytes[] memory)",
63 |     ],
64 |     "ISafe": [
65 |         "function execTransaction(address to, uint256 value, bytes data, uint8 operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, bytes signatures) payable returns (bool success)",
66 |         "function checkSignatures(bytes32 dataHash, bytes data, bytes signatures) view",
67 |         "function domainSeparator() view returns (bytes32)",
68 |         "function nonce() view returns (uint256)",
69 |     ],
70 |     "EIP-1271": ["function isValidSignature(bytes32 _hash, bytes memory _signature) public view returns (bytes4 magicValue);"],
71 | };
72 | 
73 | main().then().catch(err => {
74 |     console.error("Failed:", err)
75 |     process.exit(2);
76 | })
77 | 
78 | async function main() {
79 |     const r = whatsabi.interfaces.createInterfaceIndex(interfaces);
80 |     // Print typescript structure
81 |     console.log("// Generated using examples/index-interfaces.ts");
82 |     console.log("export default {");
83 |     for (const [key, setValue] of Object.entries(r)) {
84 |         if (setValue.size === 0) { continue; }
85 |         console.log(`  "${key}": new Set([${Array.from(setValue).map(v => `"${v}"`).join(", ")}]),`);
86 |     }
87 |     console.log("};");
88 | };
89 | 


--------------------------------------------------------------------------------
/examples/resolveproxy.ts:
--------------------------------------------------------------------------------
 1 | #!/usr/bin/env -S tsx
 2 | 
 3 | import { ethers } from "ethers";
 4 | 
 5 | import { DiamondProxyResolver } from '../src/proxies.js';
 6 | import { disasm } from '../src/disasm.js';
 7 | import { withCache } from "../src/internal/filecache.js";
 8 | import { opcodes } from "../src/opcodes.js";
 9 | import { CompatibleProvider } from "../src/providers.js";
10 | 
11 | const { INFURA_API_KEY } = process.env;
12 | const provider = CompatibleProvider(INFURA_API_KEY ? (new ethers.InfuraProvider("homestead", INFURA_API_KEY)) : ethers.getDefaultProvider("homestead"));
13 | 
14 | async function main() {
15 |     const address = process.env["ADDRESS"] || process.argv[2];
16 |     const selector = process.env["SELECTOR"] || process.argv[3];
17 | 
18 |     console.debug("Loading code for address:", address);
19 |     const code = await withCache(
20 |         `${address}_abi`,
21 |         async () => {
22 |             return await provider.getCode(address)
23 |         },
24 |     );
25 | 
26 |     const program = disasm(code);
27 | 
28 |     let hasDelegateCall = false;
29 |     for (const fn of Object.values(program.dests)) {
30 |         if (fn.opTags.has(opcodes.DELEGATECALL)) {
31 |             hasDelegateCall = true;
32 |             break;
33 |         }
34 |     }
35 | 
36 |     console.log("Detected proxies: ", program.proxies);
37 | 
38 |     for (const resolver of program.proxies) {
39 |         console.log("Resolving proxy:", resolver.toString());
40 | 
41 |         if (!selector && resolver instanceof DiamondProxyResolver) {
42 |             const facets = await (resolver as DiamondProxyResolver).facets(provider, address);
43 |             console.log("Resolved to facets: ", facets);
44 |         } else {
45 |             const addr = await resolver.resolve(provider, address, selector);
46 |             if (addr === "0x0000000000000000000000000000000000000000") continue;
47 |             console.log("Resolved to address:", addr);
48 |         }
49 | 
50 |         return;
51 |     }
52 | 
53 |     if (hasDelegateCall && program.proxies.length === 0) {
54 |         console.log("DELEGATECALL detected but no proxies found");
55 |     } else {
56 |         console.log("No DELEGATECALL detected");
57 |         return;
58 |     }
59 | 
60 | }
61 | 
62 | main().then().catch(err => {
63 |     console.error("Failed:", err)
64 |     process.exit(2);
65 | })
66 | 


--------------------------------------------------------------------------------
/flake.lock:
--------------------------------------------------------------------------------
 1 | {
 2 |   "nodes": {
 3 |     "flake-utils": {
 4 |       "inputs": {
 5 |         "systems": "systems"
 6 |       },
 7 |       "locked": {
 8 |         "lastModified": 1726560853,
 9 |         "narHash": "sha256-X6rJYSESBVr3hBoH0WbKE5KvhPU5bloyZ2L4K60/fPQ=",
10 |         "owner": "numtide",
11 |         "repo": "flake-utils",
12 |         "rev": "c1dfcf08411b08f6b8615f7d8971a2bfa81d5e8a",
13 |         "type": "github"
14 |       },
15 |       "original": {
16 |         "id": "flake-utils",
17 |         "type": "indirect"
18 |       }
19 |     },
20 |     "nixpkgs": {
21 |       "locked": {
22 |         "lastModified": 1730958623,
23 |         "narHash": "sha256-JwQZIGSYnRNOgDDoIgqKITrPVil+RMWHsZH1eE1VGN0=",
24 |         "owner": "NixOS",
25 |         "repo": "nixpkgs",
26 |         "rev": "85f7e662eda4fa3a995556527c87b2524b691933",
27 |         "type": "github"
28 |       },
29 |       "original": {
30 |         "owner": "NixOS",
31 |         "ref": "nixpkgs-unstable",
32 |         "repo": "nixpkgs",
33 |         "type": "github"
34 |       }
35 |     },
36 |     "root": {
37 |       "inputs": {
38 |         "flake-utils": "flake-utils",
39 |         "nixpkgs": "nixpkgs"
40 |       }
41 |     },
42 |     "systems": {
43 |       "locked": {
44 |         "lastModified": 1681028828,
45 |         "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
46 |         "owner": "nix-systems",
47 |         "repo": "default",
48 |         "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
49 |         "type": "github"
50 |       },
51 |       "original": {
52 |         "owner": "nix-systems",
53 |         "repo": "default",
54 |         "type": "github"
55 |       }
56 |     }
57 |   },
58 |   "root": "root",
59 |   "version": 7
60 | }
61 | 


--------------------------------------------------------------------------------
/flake.nix:
--------------------------------------------------------------------------------
 1 | {
 2 |   inputs = {
 3 |     nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
 4 |   };
 5 |   outputs = {
 6 |     nixpkgs,
 7 |     flake-utils,
 8 |     ...
 9 |   }:
10 |     flake-utils.lib.eachDefaultSystem
11 |     (system: let
12 |       pkgs = import nixpkgs {
13 |         inherit system;
14 |       };
15 |     in {
16 |       devShells.default = pkgs.mkShell {
17 |         buildInputs = with pkgs.nodePackages_latest; [
18 |           nodejs
19 |           pnpm
20 | 
21 |         ] ++ [
22 |           pkgs.graphviz  # For debugging
23 |           pkgs.gnumake
24 |         ];
25 | 
26 |         shellHook = ''
27 |           export PS1="[dev] $PS1"
28 |           export PATH=$PWD/node_modules/.bin:$PATH
29 | 
30 |           [[ ! -d node_modules ]] && pnpm install
31 | 
32 |           [[ -f .env ]] && source .env
33 |         '';
34 |       };
35 |     });
36 | }
37 | 


--------------------------------------------------------------------------------
/funding.json:
--------------------------------------------------------------------------------
1 | {
2 |   "opRetro": {
3 |     "projectId": "0xabdfa10e699db5127100da1dd2403692afe8d86e793d57780f1c7e93437a73a0"
4 |   }
5 | }
6 | 


--------------------------------------------------------------------------------
/package.cjs.json:
--------------------------------------------------------------------------------
1 | {
2 |     "type": "commonjs"
3 | }
4 | 


--------------------------------------------------------------------------------
/package.esm.json:
--------------------------------------------------------------------------------
1 | {
2 |     "type": "module",
3 |     "sideEffects": false
4 | }
5 | 


--------------------------------------------------------------------------------
/package.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "name": "@shazow/whatsabi",
 3 |   "version": "0.20.0",
 4 |   "description": "Resolve proxies and get an ABI from Ethereum bytecode, even if it's unverified",
 5 |   "type": "module",
 6 |   "scripts": {
 7 |     "test": "vitest run",
 8 |     "build:cjs": "tsc --project tsconfig.cjs.json && cp package.cjs.json lib.cjs/package.json",
 9 |     "build:esm": "tsc --project tsconfig.esm.json && cp package.esm.json lib.esm/package.json",
10 |     "build:types": "tsc --project tsconfig.types.json",
11 |     "build:docs": "typedoc"
12 |   },
13 |   "repository": {
14 |     "type": "git",
15 |     "url": "git+https://github.com/shazow/whatsabi.git"
16 |   },
17 |   "keywords": [
18 |     "ethereum",
19 |     "evm",
20 |     "abi"
21 |   ],
22 |   "author": "Andrey Petrov <shazow.net>",
23 |   "license": "MIT",
24 |   "files": [
25 |     "lib.esm/",
26 |     "lib.cjs/",
27 |     "lib.types/",
28 |     "src/",
29 |     "examples/",
30 |     "package.json",
31 |     "README.md",
32 |     "LICENSE",
33 |     "*config.*"
34 |   ],
35 |   "bugs": {
36 |     "url": "https://github.com/shazow/whatsabi/issues"
37 |   },
38 |   "homepage": "https://github.com/shazow/whatsabi#readme",
39 |   "dependencies": {
40 |     "ox": "^0.6.9"
41 |   },
42 |   "peerDependencies": {
43 |     "@noble/hashes": "^1"
44 |   },
45 |   "devDependencies": {
46 |     "@size-limit/esbuild-why": "^8.2.6",
47 |     "@size-limit/preset-small-lib": "^8.2.6",
48 |     "ethers": "^6.13.5",
49 |     "npm": "^10.9.2",
50 |     "size-limit": "^8.2.6",
51 |     "tsx": "^4.19.3",
52 |     "typedoc": "^0.26.11",
53 |     "typedoc-plugin-missing-exports": "^3.1.0",
54 |     "viem": "^2.23.5",
55 |     "vitest": "^0.34.6",
56 |     "web3": "^4.16.0"
57 |   },
58 |   "main": "./lib.cjs/index.js",
59 |   "module": "./lib.esm/index.js",
60 |   "types": "./lib.types/index.d.ts",
61 |   "exports": {
62 |     ".": {
63 |       "types": "./lib.types/index.d.ts",
64 |       "import": "./lib.esm/index.js",
65 |       "default": "./lib.cjs/index.js"
66 |     }
67 |   }
68 | }
69 | 


--------------------------------------------------------------------------------
/src/__tests__/__fixtures__/proxies.ts:
--------------------------------------------------------------------------------
1 | export const ZEPPELINOS_USDC = "608060405234801561001057600080fd5b50604051602080610b2983398101806040528101908080519060200190929190505050808060405180807f6f72672e7a657070656c696e6f732e70726f78792e696d706c656d656e74617481526020017f696f6e000000000000000000000000000000000000000000000000000000000081525060230190506040518091039020600019167f7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3600102600019161415156100c657fe5b6100de81610169640100000000026401000000009004565b5060405180807f6f72672e7a657070656c696e6f732e70726f78792e61646d696e000000000000815250601a0190506040518091039020600019167f10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b6001026000191614151561014a57fe5b6101623361024e640100000000026401000000009004565b5050610290565b60006101878261027d6401000000000261084b176401000000009004565b1515610221576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603b8152602001807f43616e6e6f742073657420612070726f787920696d706c656d656e746174696f81526020017f6e20746f2061206e6f6e2d636f6e74726163742061646472657373000000000081525060400191505060405180910390fd5b7f7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c360010290508181555050565b60007f10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b60010290508181555050565b600080823b905060008111915050919050565b61088a8061029f6000396000f30060806040526004361061006d576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680633659cfe6146100775780634f1ef286146100ba5780635c60da1b146101085780638f2839701461015f578063f851a440146101a2575b6100756101f9565b005b34801561008357600080fd5b506100b8600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610213565b005b610106600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001908201803590602001919091929391929390505050610268565b005b34801561011457600080fd5b5061011d610308565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561016b57600080fd5b506101a0600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610360565b005b3480156101ae57600080fd5b506101b761051e565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b610201610576565b61021161020c610651565b610682565b565b61021b6106a8565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141561025c57610257816106d9565b610265565b6102646101f9565b5b50565b6102706106a8565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614156102fa576102ac836106d9565b3073ffffffffffffffffffffffffffffffffffffffff163483836040518083838082843782019150509250505060006040518083038185875af19250505015156102f557600080fd5b610303565b6103026101f9565b5b505050565b60006103126106a8565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614156103545761034d610651565b905061035d565b61035c6101f9565b5b90565b6103686106a8565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141561051257600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614151515610466576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260368152602001807f43616e6e6f74206368616e6765207468652061646d696e206f6620612070726f81526020017f787920746f20746865207a65726f20616464726573730000000000000000000081525060400191505060405180910390fd5b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f61048f6106a8565b82604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019250505060405180910390a161050d81610748565b61051b565b61051a6101f9565b5b50565b60006105286106a8565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141561056a576105636106a8565b9050610573565b6105726101f9565b5b90565b61057e6106a8565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151515610647576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260328152602001807f43616e6e6f742063616c6c2066616c6c6261636b2066756e6374696f6e20667281526020017f6f6d207468652070726f78792061646d696e000000000000000000000000000081525060400191505060405180910390fd5b61064f610777565b565b6000807f7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c36001029050805491505090565b3660008037600080366000845af43d6000803e80600081146106a3573d6000f35b3d6000fd5b6000807f10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b6001029050805491505090565b6106e281610779565b7fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b81604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a150565b60007f10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b60010290508181555050565b565b60006107848261084b565b151561081e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603b8152602001807f43616e6e6f742073657420612070726f787920696d706c656d656e746174696f81526020017f6e20746f2061206e6f6e2d636f6e74726163742061646472657373000000000081525060400191505060405180910390fd5b7f7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c360010290508181555050565b600080823b9050600081119150509190505600a165627a7a72305820a4a547cfc7202c5acaaae74d428e988bc62ad5024eb0165532d3a8f91db4ed2400290000000000000000000000000882477e7895bdc5cea7cb1552ed914ab157fe56";
2 | 
3 | export const WANDERWING = "0x60806040523661000b57005b60007fbec77a503c47907b093281e779d211f6b514083b5f8064a268e3b9dcae86aa87546040517fc2c95814000000000000000000000000000000000000000000000000000000008152600080357fffffffff0000000000000000000000000000000000000000000000000000000016600483015273ffffffffffffffffffffffffffffffffffffffff9092169250829063c2c9581490602401602060405180830381865afa1580156100c2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100e6919061010f565b90503660008037600080366000845af43d6000803e808015610107573d6000f35b3d6000fd5b90565b60006020828403121561012157600080fd5b815173ffffffffffffffffffffffffffffffffffffffff8116811461014557600080fd5b939250505056fea2646970667358221220eb78d73a79b6dd591ef8d70f3f61a662e4117947412c92af1f5fd19080a7852364736f6c63430008120033";
4 | 


--------------------------------------------------------------------------------
/src/__tests__/__fixtures__/sample.ts:
--------------------------------------------------------------------------------
 1 | export const SAMPLE_ABI = [
 2 |   {"inputs":[{"internalType":"address","name":"_ketherNFTContract","type":"address"},{"internalType":"address","name":"_ketherContract","type":"address"},{"internalType":"address","name":"vrfCoordinator","type":"address"},{"internalType":"address","name":"link","type":"address"},{"internalType":"bytes32","name":"keyHash","type":"bytes32"},{"internalType":"uint256","name":"fee","type":"uint256"},{"internalType":"uint256","name":"_termDuration","type":"uint256"},{"internalType":"uint256","name":"_minElectionDuration","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},
 3 |   {"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"termNumber","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"magistrateToken","type":"uint256"},{"indexed":false,"internalType":"address","name":"currentTokenOwner","type":"address"}],"name":"ElectionCompleted","type":"event"},
 4 |   {"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"termNumber","type":"uint256"}],"name":"ElectionExecuting","type":"event"},
 5 |   {"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"termNumber","type":"uint256"},{"indexed":false,"internalType":"address","name":"nominator","type":"address"},{"indexed":false,"internalType":"uint256","name":"pixels","type":"uint256"}],"name":"Nominated","type":"event"},
 6 |   {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},
 7 |   {"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"termNumber","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"ReceivedPayment","type":"event"},
 8 |   {"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"termNumber","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"magistrateToken","type":"uint256"},{"indexed":false,"internalType":"address","name":"currentTokenOwner","type":"address"}],"name":"StepDown","type":"event"},
 9 |   {"inputs":[{"internalType":"contract IERC20","name":"token","type":"address"},{"internalType":"address","name":"to","type":"address"}],"name":"adminWithdrawToken","outputs":[],"stateMutability":"nonpayable","type":"function"},
10 |   {"inputs":[],"name":"completeElection","outputs":[],"stateMutability":"nonpayable","type":"function"},
11 |   {"inputs":[],"name":"electionEntropy","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
12 |   {"inputs":[{"internalType":"uint256","name":"_idx","type":"uint256"}],"name":"getAdOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
13 |   {"inputs":[{"internalType":"uint256","name":"_idx","type":"uint256"}],"name":"getAdPixels","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
14 |   {"inputs":[],"name":"getMagistrate","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
15 |   {"inputs":[],"name":"getNextMagistrateToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
16 |   {"inputs":[{"internalType":"uint256","name":"_idx","type":"uint256"}],"name":"getNominatedToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
17 |   {"inputs":[{"internalType":"uint256","name":"_idx","type":"uint256"}],"name":"isNominated","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
18 |   {"inputs":[],"name":"magistrateToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
19 |   {"inputs":[],"name":"minElectionDuration","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
20 |   {"inputs":[{"internalType":"uint256","name":"_ownedTokenId","type":"uint256"},{"internalType":"uint256","name":"_nominateTokenId","type":"uint256"}],"name":"nominate","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},
21 |   {"inputs":[{"internalType":"uint256","name":"_nominateTokenId","type":"uint256"}],"name":"nominateAll","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},
22 |   {"inputs":[],"name":"nominateSelf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},
23 |   {"inputs":[],"name":"nominatedPixels","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
24 |   {"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"nominatedTokens","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
25 |   {"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
26 |   {"inputs":[{"internalType":"bytes32","name":"requestId","type":"bytes32"},{"internalType":"uint256","name":"randomness","type":"uint256"}],"name":"rawFulfillRandomness","outputs":[],"stateMutability":"nonpayable","type":"function"},
27 |   {"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},
28 |   {"inputs":[],"name":"startElection","outputs":[],"stateMutability":"nonpayable","type":"function"},
29 |   {"inputs":[],"name":"state","outputs":[{"internalType":"enum KetherSortition.StateMachine","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},
30 |   {"inputs":[],"name":"stepDown","outputs":[],"stateMutability":"nonpayable","type":"function"},
31 |   {"inputs":[],"name":"termDuration","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
32 |   {"inputs":[],"name":"termExpires","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
33 |   {"inputs":[],"name":"termNumber","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
34 |   {"inputs":[],"name":"termStarted","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
35 |   {"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},
36 |   {"inputs":[{"internalType":"address payable","name":"to","type":"address"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},
37 |   {"stateMutability":"payable","type":"receive"}];
38 | 
39 | export const SAMPLE_CODE = '0x6080604052600436106101ba5760003560e01c80638da5cb5b116100ec578063c19d93fb1161008a578063dac1916511610064578063dac1916514610498578063ea97b95a146104d7578063f2612375146104f7578063f2fde38b1461050c57600080fd5b8063c19d93fb14610445578063c22bd3de1461046c578063d83d32411461048257600080fd5b80639a5f104b116100c65780639a5f104b146103da5780639ee3fe93146103ef578063a4a307061461040f578063ba566dea1461042f57600080fd5b80638da5cb5b1461037c57806394985ddd1461039a5780639a158cf7146103ba57600080fd5b806355843fda1161015957806362d73eb81161013357806362d73eb81461031d578063715018a61461033257806385c6ef0514610347578063879d87661461036757600080fd5b806355843fda146102c45780635cb00514146102f15780635dab507b1461030757600080fd5b80631b861c0e116101955780631b861c0e146102625780632f306aea1461027957806341787f861461028e57806351cff8d9146102a457600080fd5b80626a08a21461020057806306a91d54146102365780630bfe4e721461024c57600080fd5b366101fb576007547f6d6d16a774a787642f0ba008c0fff68787f55008be6af89c381a7b65d680ee86346040516101f19190611d36565b60405180910390a2005b600080fd5b34801561020c57600080fd5b5061022061021b366004611ad3565b61052c565b60405161022d9190611d36565b60405180910390f35b34801561024257600080fd5b5061022060045481565b34801561025857600080fd5b5061022060055481565b34801561026e57600080fd5b506102776105ae565b005b34801561028557600080fd5b506102776106bf565b34801561029a57600080fd5b5061022060025481565b3480156102b057600080fd5b506102776102bf3660046118ee565b610787565b3480156102d057600080fd5b506102e46102df366004611ad3565b610814565b60405161022d9190611bf6565b3480156102fd57600080fd5b50610220600b5481565b34801561031357600080fd5b50610220600d5481565b34801561032957600080fd5b5061027761089b565b34801561033e57600080fd5b50610277610ae3565b34801561035357600080fd5b50610277610362366004611aa3565b610b19565b34801561037357600080fd5b50610220610c3d565b34801561038857600080fd5b506000546001600160a01b03166102e4565b3480156103a657600080fd5b506102776103b5366004611a69565b610d9e565b3480156103c657600080fd5b506102206103d5366004611a69565b610df0565b3480156103e657600080fd5b506102e4611030565b3480156103fb57600080fd5b5061022061040a366004611ad3565b611042565b34801561041b57600080fd5b5061022061042a366004611ad3565b61104f565b34801561043b57600080fd5b5061022060075481565b34801561045157600080fd5b50600e5461045f9060ff1681565b60405161022d9190611cad565b34801561047857600080fd5b5061022060065481565b34801561048e57600080fd5b5061022060035481565b3480156104a457600080fd5b506104ca6104b3366004611ad3565b6007546000918252600c6020526040909120541190565b60405161022d9190611c5c565b3480156104e357600080fd5b506102206104f2366004611ad3565b611070565b34801561050357600080fd5b50610220611124565b34801561051857600080fd5b506102776105273660046118ee565b611132565b6007546000828152600c6020526040812054909110604051806040016040528060168152602001751d1bdad95b881a5cc81b9bdd081b9bdb5a5b985d195960521b815250906105975760405162461bcd60e51b815260040161058e9190611cbb565b60405180910390fd5b50506000908152600c602052604090206001015490565b6002600e5460ff1660028111156105d557634e487b7160e01b600052602160045260246000fd5b146040518060400160405280601381526020017277616974696e6720666f7220656e74726f707960681b815250906106205760405162461bcd60e51b815260040161058e9190611cbb565b50610629610c3d565b6002819055506001600760008282546106429190611da6565b909155505042600581905560035461065991611da6565b600655610668600a600061181b565b6000600b55600e805460ff191690556007546002547fa4fcb6e591e4ccbea64b125b565270836f432a5e1483dc72885ced2cf99c6bdd906106a7611030565b6040516106b5929190611d44565b60405180910390a2565b6106c7611030565b6001600160a01b0316336001600160a01b031614604051806060016040528060228152602001611f4560229139906107125760405162461bcd60e51b815260040161058e9190611cbb565b506000426006546107239190611ddd565b90506004548111156107405760045461073c9042611da6565b6006555b6007547f5e881305b2cfbcb2847e98ef3b3fa331cd422083593e55a9f0929b73ba71982e60025461076e3390565b60405161077c929190611d44565b60405180910390a250565b61078f611030565b6001600160a01b0316336001600160a01b031614604051806060016040528060228152602001611f4560229139906107da5760405162461bcd60e51b815260040161058e9190611cbb565b506040516001600160a01b038216904780156108fc02916000818181858888f19350505050158015610810573d6000803e3d6000fd5b5050565b6008546040516331a9108f60e11b81526000916001600160a01b031690636352211e90610845908590600401611d36565b60206040518083038186803b15801561085d57600080fd5b505afa158015610871573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610895919061190c565b92915050565b6000600e5460ff1660028111156108c257634e487b7160e01b600052602160045260246000fd5b1460405180604001604052806018815260200177195b1958dd1a5bdb88185b1c9958591e481cdd185c9d195960421b815250906109125760405162461bcd60e51b815260040161058e9190611cbb565b50600a546040805180820190915260158152746d7573742068617665206e6f6d696e6174696f6e7360581b6020820152906109605760405162461bcd60e51b815260040161058e9190611cbb565b504260065411156040518060400160405280601081526020016f1d195c9b481b9bdd08195e1c1a5c995960821b815250906109ae5760405162461bcd60e51b815260040161058e9190611cbb565b506010546040516370a0823160e01b81526001600160a01b037f000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca16906370a08231906109fe903090600401611bf6565b60206040518083038186803b158015610a1657600080fd5b505afa158015610a2a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a4e9190611af1565b10156040518060400160405280600f81526020016e6e6f7420656e6f756768204c494e4b60881b81525090610a965760405162461bcd60e51b815260040161058e9190611cbb565b50600e805460ff19166001179055600f54601054610ab4919061118e565b506007546040517fd6b9c88e1047b23a40de1375326b23f428b9b2d05985d61ddc3bbac444eb4d6e90600090a2565b6000546001600160a01b03163314610b0d5760405162461bcd60e51b815260040161058e90611d16565b610b1760006112cb565b565b6000546001600160a01b03163314610b435760405162461bcd60e51b815260040161058e90611d16565b6040516370a0823160e01b81526001600160a01b0383169063a9059cbb90839083906370a0823190610b79903090600401611bf6565b60206040518083038186803b158015610b9157600080fd5b505afa158015610ba5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bc99190611af1565b6040518363ffffffff1660e01b8152600401610be6929190611c04565b602060405180830381600087803b158015610c0057600080fd5b505af1158015610c14573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c389190611a4b565b505050565b60006002600e5460ff166002811115610c6657634e487b7160e01b600052602160045260246000fd5b146040518060400160405280601381526020017277616974696e6720666f7220656e74726f707960681b81525090610cb15760405162461bcd60e51b815260040161058e9190611cbb565b50600a546040805180820190915260158152746d7573742068617665206e6f6d696e6174696f6e7360581b602082015290610cff5760405162461bcd60e51b815260040161058e9190611cbb565b506000600b54600d54610d129190611e9d565b90506000805b600a54811015610d94576000600a8281548110610d4557634e487b7160e01b600052603260045260246000fd5b90600052602060002001549050610d5b81611070565b610d659084611da6565b925083831115610d8157610d788161052c565b94505050505090565b5080610d8c81611e82565b915050610d18565b5060009250505090565b336001600160a01b037f000000000000000000000000f0d54349addcf704f77ae15b96510dea15cb79521614610de65760405162461bcd60e51b815260040161058e90611d26565b610810828261131b565b600080600e5460ff166002811115610e1857634e487b7160e01b600052602160045260246000fd5b1460405180604001604052806018815260200177195b1958dd1a5bdb88185b1c9958591e481cdd185c9d195960421b81525090610e685760405162461bcd60e51b815260040161058e9190611cbb565b506008546040516331a9108f60e11b8152339182916001600160a01b0390911690636352211e90610e9d908890600401611d36565b60206040518083038186803b158015610eb557600080fd5b505afa158015610ec9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eed919061190c565b6001600160a01b0316146040518060400160405280600e81526020016d36bab9ba1037bbb7103a37b5b2b760911b81525090610f3c5760405162461bcd60e51b815260040161058e9190611cbb565b506008546040516331a9108f60e11b81526000916001600160a01b031690636352211e90610f6e908790600401611d36565b60206040518083038186803b158015610f8657600080fd5b505afa158015610f9a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fbe919061190c565b6001600160a01b03161415610fd257600080fd5b6000610fde85856113a3565b90506007546001610fef9190611da6565b7f410c64408a68c77e8979ef9387e9ea8d60705de1e4891e4fe821946dde6640ef8383604051611020929190611c04565b60405180910390a2949350505050565b600061103d600254610814565b905090565b600061089560008361144b565b600a818154811061105f57600080fd5b600091825260209091200154905081565b60095460405162469e9360e61b8152600091829182916001600160a01b0316906311a7a4c0906110a4908790600401611d36565b60006040518083038186803b1580156110bc57600080fd5b505afa1580156110d0573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526110f8919081019061192a565b505050505094509450505050606481836111129190611dbe565b61111c9190611dbe565b949350505050565b600061103d6001600061144b565b6000546001600160a01b0316331461115c5760405162461bcd60e51b815260040161058e90611d16565b6001600160a01b0381166111825760405162461bcd60e51b815260040161058e90611ccc565b61118b816112cb565b50565b60007f000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca6001600160a01b0316634000aea07f000000000000000000000000f0d54349addcf704f77ae15b96510dea15cb7952848660006040516020016111f5929190611c6a565b6040516020818303038152906040526040518463ffffffff1660e01b815260040161122293929190611c26565b602060405180830381600087803b15801561123c57600080fd5b505af1158015611250573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112749190611a4b565b50600083815260016020526040812054611293908590839030906117ae565b6000858152600160208190526040909120549192506112b29190611da6565b60008581526001602052604090205561111c84826117e8565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600e5460ff16600281111561134257634e487b7160e01b600052602160045260246000fd5b1460405180604001604052806015815260200174195b1958dd1a5bdb881b9bdd08195e1958dd5d1959605a1b8152509061138f5760405162461bcd60e51b815260040161058e9190611cbb565b50600d5550600e805460ff19166002179055565b6007546000838152600c6020526040812054909110611407576113c583611070565b6113cf9082611da6565b600a80546001810182556000919091527fc65a7bb8d6351c1cf70c95a316cc6a92839c986682d98bc35f958f4883f9d2a80184905590505b604051806040016040528060075460016114219190611da6565b815260209081018490526000858152600c8252604090208251815591015160019091015592915050565b600080600e5460ff16600281111561147357634e487b7160e01b600052602160045260246000fd5b1460405180604001604052806018815260200177195b1958dd1a5bdb88185b1c9958591e481cdd185c9d195960421b815250906114c35760405162461bcd60e51b815260040161058e9190611cbb565b506008546040516370a0823160e01b815233916000916001600160a01b03909116906370a08231906114f9908590600401611bf6565b60206040518083038186803b15801561151157600080fd5b505afa158015611525573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115499190611af1565b116040518060400160405280600e81526020016d36bab9ba1037bbb7103a37b5b2b760911b8152509061158f5760405162461bcd60e51b815260040161058e9190611cbb565b50838061162457506008546040516331a9108f60e11b81526000916001600160a01b031690636352211e906115c8908790600401611d36565b60206040518083038186803b1580156115e057600080fd5b505afa1580156115f4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611618919061190c565b6001600160a01b031614155b61162d57600080fd5b6000805b6008546040516370a0823160e01b81526001600160a01b03909116906370a0823190611661908690600401611bf6565b60206040518083038186803b15801561167957600080fd5b505afa15801561168d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116b19190611af1565b81101561178857600854604051632f745c5960e01b81526000916001600160a01b031690632f745c59906116eb9087908690600401611c04565b60206040518083038186803b15801561170357600080fd5b505afa158015611717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061173b9190611af1565b9050861561175e5761174d81826113a3565b6117579084611da6565b9250611775565b61176881876113a3565b6117729084611da6565b92505b508061178081611e82565b915050611631565b5080600b600082825461179b9190611da6565b9091555050600754610fef906001611da6565b6000848484846040516020016117c79493929190611c78565b60408051601f19818403018152919052805160209091012095945050505050565b600082826040516020016117fd929190611bd0565b60405160208183030381529060405280519060200120905092915050565b508054600082559060005260206000209081019061118b91905b808211156118495760008155600101611835565b5090565b600061186061185b84611d7b565b611d5f565b90508281526020810184848401111561187857600080fd5b611883848285611e25565b509392505050565b803561089581611f19565b805161089581611f19565b805161089581611f2d565b803561089581611f35565b803561089581611f3b565b600082601f8301126118d357600080fd5b815161111c84826020860161184d565b805161089581611f35565b60006020828403121561190057600080fd5b600061111c848461188b565b60006020828403121561191e57600080fd5b600061111c8484611896565b6000806000806000806000806000806101408b8d03121561194a57600080fd5b60006119568d8d611896565b9a505060206119678d828e016118e3565b99505060406119788d828e016118e3565b98505060606119898d828e016118e3565b975050608061199a8d828e016118e3565b96505060a08b015167ffffffffffffffff8111156119b757600080fd5b6119c38d828e016118c2565b95505060c08b015167ffffffffffffffff8111156119e057600080fd5b6119ec8d828e016118c2565b94505060e08b015167ffffffffffffffff811115611a0957600080fd5b611a158d828e016118c2565b935050610100611a278d828e016118a1565b925050610120611a398d828e016118a1565b9150509295989b9194979a5092959850565b600060208284031215611a5d57600080fd5b600061111c84846118a1565b60008060408385031215611a7c57600080fd5b6000611a8885856118ac565b9250506020611a99858286016118ac565b9150509250929050565b60008060408385031215611ab657600080fd5b6000611ac285856118b7565b9250506020611a998582860161188b565b600060208284031215611ae557600080fd5b600061111c84846118ac565b600060208284031215611b0357600080fd5b600061111c84846118e3565b611b1881611df4565b82525050565b801515611b18565b80611b18565b6000611b36825190565b808452602084019350611b4d818560208601611e25565b601f01601f19169290920192915050565b611b1881611e1a565b60208082527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572910190815260005b5060200190565b601f81526000602082017f4f6e6c7920565246436f6f7264696e61746f722063616e2066756c66696c6c0081529150611b95565b6000611bdc8285611b26565b602082019150611bec8284611b26565b5060200192915050565b602081016108958284611b0f565b60408101611c128285611b0f565b611c1f6020830184611b26565b9392505050565b60608101611c348286611b0f565b611c416020830185611b26565b8181036040830152611c538184611b2c565b95945050505050565b602081016108958284611b1e565b60408101611c128285611b26565b60808101611c868287611b26565b611c936020830186611b26565b611ca06040830185611b0f565b611c536060830184611b26565b602081016108958284611b5e565b60208082528101611c1f8184611b2c565b6020808252810161089581602681527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160208201526564647265737360d01b604082015260600190565b6020808252810161089581611b67565b6020808252810161089581611b9c565b602081016108958284611b26565b60408101611d528285611b26565b611c1f6020830184611b0f565b6000611d6a60405190565b9050611d768282611e55565b919050565b600067ffffffffffffffff821115611d9557611d95611ef3565b601f19601f83011660200192915050565b60008219821115611db957611db9611eb1565b500190565b6000816000190483118215151615611dd857611dd8611eb1565b500290565b600082821015611def57611def611eb1565b500390565b60006001600160a01b038216610895565b600061089582611df4565b80611d7681611f09565b600061089582611e10565b60005b83811015611e40578181015183820152602001611e28565b83811115611e4f576000848401525b50505050565b601f19601f830116810181811067ffffffffffffffff82111715611e7b57611e7b611ef3565b6040525050565b6000600019821415611e9657611e96611eb1565b5060010190565b600082611eac57611eac611ec7565b500690565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6003811061118b5761118b611edd565b611f2281611df4565b811461118b57600080fd5b801515611f22565b80611f22565b611f2281611e0556fe6f6e6c7920616374697665206d6167697374726174652063616e20646f2074686973a2646970667358221220b50563076776b8b35629dd89275e18a436918f3c8eb8b3f8a389a04131bd9b0e64736f6c63430008040033';
40 | 


--------------------------------------------------------------------------------
/src/__tests__/__fixtures__/sample2.ts:
--------------------------------------------------------------------------------
1 | export const SAMPLE_ABI = ["retrieve()","store(uint256)"];
2 | 
3 | export const SAMPLE_CODE = '608060405234801561001057600080fd5b50600436106100365760003560e01c80632e64cec11461003b5780636057361d14610059575b600080fd5b610043610075565b60405161005091906100d9565b60405180910390f35b610073600480360381019061006e919061009d565b61007e565b005b60008054905090565b8060008190555050565b60008135905061009781610103565b92915050565b6000602082840312156100b3576100b26100fe565b5b60006100c184828501610088565b91505092915050565b6100d3816100f4565b82525050565b60006020820190506100ee60008301846100ca565b92915050565b6000819050919050565b600080fd5b61010c816100f4565b811461011757600080fd5b5056fea2646970667358221220404e37f487a89a932dca5e77faaf6ca2de3b991f93d230604b1b8daaef64766264736f6c63430008070033';
4 | 


--------------------------------------------------------------------------------
/src/__tests__/abi.test.ts:
--------------------------------------------------------------------------------
  1 | import { expect, describe, it } from "vitest";
  2 | 
  3 | import { ABI, fillEmptyNames } from "../abi";
  4 | 
  5 | describe("fillEmptyNames", () => {
  6 |   type testCase = {
  7 |     name: string;
  8 |     abi: Array<ABI[number] | unknown>;
  9 |     want: Array<ABI[number] | unknown>;
 10 |   };
 11 | 
 12 |   const testCases: testCase[] = [
 13 |     {
 14 |       name: "Basic test",
 15 |       abi: [
 16 |         {
 17 |           type: "function",
 18 |           selector: "0x95d376d7",
 19 |           payable: false,
 20 |           stateMutability: "payable",
 21 |           inputs: [
 22 |             {
 23 |               type: "tuple",
 24 |               name: "",
 25 |               components: [
 26 |                 { type: "uint32", name: "" },
 27 |                 { type: "bytes", name: "" },
 28 |                 { type: "bytes32", name: "" },
 29 |                 { type: "uint64", name: "" },
 30 |                 { type: "address", name: "" },
 31 |               ],
 32 |             },
 33 |             { type: "bytes", name: "" },
 34 |           ],
 35 |           outputs: [
 36 |             {
 37 |               type: "tuple",
 38 |               name: "",
 39 |               components: [
 40 |                 { type: "uint32", name: "" },
 41 |                 { type: "bytes", name: "" },
 42 |                 { type: "bytes32", name: "" },
 43 |                 { type: "uint64", name: "" },
 44 |                 { type: "address", name: "" },
 45 |               ],
 46 |             },
 47 |             { type: "bytes", name: "" },
 48 |           ],
 49 |           sig: "assignJob((uint32,bytes,bytes32,uint64,address),bytes)",
 50 |           name: "assignJob",
 51 |           constant: false,
 52 |         },
 53 |       ],
 54 |       want: [
 55 |         {
 56 |           type: "function",
 57 |           selector: "0x95d376d7",
 58 |           payable: false,
 59 |           stateMutability: "payable",
 60 |           inputs: [
 61 |             {
 62 |               type: "tuple",
 63 |               name: "",
 64 |               components: [
 65 |                 { type: "uint32", name: "_param0" },
 66 |                 { type: "bytes", name: "_param1" },
 67 |                 { type: "bytes32", name: "_param2" },
 68 |                 { type: "uint64", name: "_param3" },
 69 |                 { type: "address", name: "_param4" },
 70 |               ],
 71 |             },
 72 |             { type: "bytes", name: "" },
 73 |           ],
 74 |           outputs: [
 75 |             {
 76 |               type: "tuple",
 77 |               name: "",
 78 |               components: [
 79 |                 { type: "uint32", name: "_param0" },
 80 |                 { type: "bytes", name: "_param1" },
 81 |                 { type: "bytes32", name: "_param2" },
 82 |                 { type: "uint64", name: "_param3" },
 83 |                 { type: "address", name: "_param4" },
 84 |               ],
 85 |             },
 86 |             { type: "bytes", name: "" },
 87 |           ],
 88 |           sig: "assignJob((uint32,bytes,bytes32,uint64,address),bytes)",
 89 |           name: "assignJob",
 90 |           constant: false,
 91 |         },
 92 |       ],
 93 |     },
 94 |     {
 95 |       name: "Nested tuple test",
 96 |       abi: [
 97 |         {
 98 |           name: "test",
 99 |           selector: "0x12345679",
100 |           inputs: [
101 |             {
102 |               name: "",
103 |               type: "tuple",
104 |               components: [
105 |                 {
106 |                   type: "tuple",
107 |                   name: "",
108 |                   components: [
109 |                     {
110 |                       type: "tuple",
111 |                       name: "",
112 |                       components: [
113 |                         { type: "uint256", name: "" },
114 |                         { type: "address", name: "x" },
115 |                       ],
116 |                     },
117 |                     {
118 |                       type: "tuple",
119 |                       name: "n1",
120 |                       components: [
121 |                         { type: "uint256", name: "y" },
122 |                         { type: "address", name: "" },
123 |                       ],
124 |                     },
125 |                   ],
126 |                 },
127 |               ],
128 |             },
129 |           ],
130 |           stateMutability: "view",
131 |           type: "function",
132 |         },
133 |       ],
134 |       want: [
135 |         {
136 |           name: "test",
137 |           selector: "0x12345679",
138 |           inputs: [
139 |             {
140 |               name: "",
141 |               type: "tuple",
142 |               components: [
143 |                 {
144 |                   type: "tuple",
145 |                   name: "_param0",
146 |                   components: [
147 |                     {
148 |                       type: "tuple",
149 |                       name: "_param0",
150 |                       components: [
151 |                         {
152 |                           type: "uint256",
153 |                           name: "_param0",
154 |                         },
155 |                         { type: "address", name: "x" },
156 |                       ],
157 |                     },
158 |                     {
159 |                       type: "tuple",
160 |                       name: "n1",
161 |                       components: [
162 |                         { type: "uint256", name: "y" },
163 |                         {
164 |                           type: "address",
165 |                           name: "_param1",
166 |                         },
167 |                       ],
168 |                     },
169 |                   ],
170 |                 },
171 |               ],
172 |             },
173 |           ],
174 |           stateMutability: "view",
175 |           type: "function",
176 |         },
177 |       ],
178 |     },
179 |     {
180 |       name: "Other Tuple types: Tuple[] and Tuple[k]",
181 |       abi: [
182 |         {
183 |           name: "test",
184 |           selector: "0x12345679",
185 |           inputs: [
186 |             {
187 |               name: "",
188 |               type: "tuple",
189 |               components: [
190 |                 {
191 |                   name: "",
192 |                   type: "tuple[]",
193 |                   components: [
194 |                     { name: "", type: "uint256" },
195 |                     { name: "", type: "uint256" },
196 |                   ],
197 |                 },
198 |                 {
199 |                   name: "",
200 |                   type: "tuple[2]",
201 |                   components: [
202 |                     { name: "", type: "uint256" },
203 |                     { name: "", type: "uint256" },
204 |                   ],
205 |                 },
206 |               ],
207 |             },
208 |           ],
209 |           stateMutability: "view",
210 |           type: "function",
211 |         },
212 |       ],
213 |       want: [
214 |         {
215 |           name: "test",
216 |           selector: "0x12345679",
217 |           inputs: [
218 |             {
219 |               name: "",
220 |               type: "tuple",
221 |               components: [
222 |                 {
223 |                   name: "_param0",
224 |                   type: "tuple[]",
225 |                   components: [
226 |                     { name: "_param0", type: "uint256" },
227 |                     { name: "_param1", type: "uint256" },
228 |                   ],
229 |                 },
230 |                 {
231 |                   name: "_param1",
232 |                   type: "tuple[2]",
233 |                   components: [
234 |                     { name: "_param0", type: "uint256" },
235 |                     { name: "_param1", type: "uint256" },
236 |                   ],
237 |                 },
238 |               ],
239 |             },
240 |           ],
241 |           stateMutability: "view",
242 |           type: "function",
243 |         },
244 |       ],
245 |     },
246 |     {
247 |       name: "Empty ABI",
248 |       abi: [],
249 |       want: [],
250 |     },
251 |   ];
252 | 
253 |   testCases.forEach((tc) => {
254 |     it(tc.name, () => {
255 |       expect(fillEmptyNames(tc.abi as ABI)).toStrictEqual(tc.want);
256 |     });
257 |   });
258 | });
259 | 


--------------------------------------------------------------------------------
/src/__tests__/auto.test.ts:
--------------------------------------------------------------------------------
  1 | import { expect } from "vitest";
  2 | 
  3 | import { whatsabi } from "../index";
  4 | import { autoload } from "../auto";
  5 | 
  6 | import { test, online_test, cached_test, makeProvider } from "./env";
  7 | 
  8 | const TIMEOUT = 15000;
  9 | 
 10 | test('autoload throws typed error', async () => {
 11 |     // @ts-expect-error: Expected 2 arguments, but got 1
 12 |     await expect(autoload("0xf00")).rejects.toThrow(new RegExp("config is undefined"));
 13 | 
 14 |     const fakeProvider = {
 15 |         request: () => { },
 16 |     };
 17 |     await expect(autoload("abc.eth", { provider: fakeProvider })).rejects.toThrow(new RegExp("Failed to resolve ENS"));
 18 | });
 19 | 
 20 | test('autoload sets hasCode to false if code is empty', async () => {
 21 |     const fakeProvider = (code: string) => ({
 22 |       request: () => code,
 23 |     });
 24 |     const address = "0x00000000219ab540356cBB839Cbe05303d7705Fa"
 25 |     await expect(autoload(address, { provider: fakeProvider("0x") })).resolves.toMatchObject({ hasCode: false });
 26 |     await expect(autoload(address, { provider: fakeProvider("0x1234") })).resolves.toMatchObject({ hasCode: true });
 27 | });
 28 | 
 29 | online_test('autoload selectors', async ({ provider }) => {
 30 |     const address = "0x4A137FD5e7a256eF08A7De531A17D0BE0cc7B6b6"; // Random unverified contract
 31 |     const { abi } = await autoload(address, {
 32 |         provider: provider,
 33 |         abiLoader: false,
 34 |         signatureLookup: false,
 35 |     });
 36 |     expect(abi).toContainEqual({ "selector": "0x6dbf2fa0", "type": "function" });
 37 |     expect(abi).toContainEqual({ "selector": "0xec0ab6a7", "type": "function" });
 38 | }, TIMEOUT);
 39 | 
 40 | online_test('autoload selectors with experimental metadata', async ({ provider }) => {
 41 |     const address = "0x4A137FD5e7a256eF08A7De531A17D0BE0cc7B6b6"; // Random unverified contract
 42 |     const { abi } = await autoload(address, {
 43 |         provider: provider,
 44 |         abiLoader: false,
 45 |         signatureLookup: false,
 46 |         enableExperimentalMetadata: true,
 47 |     });
 48 |     expect(abi).toContainEqual({ "inputs": [{ "type": "bytes", "name": "" }], "payable": true, "selector": "0x6dbf2fa0", "stateMutability": "payable", "type": "function" });
 49 |     expect(abi).toContainEqual({ "inputs": [{ "type": "bytes", "name": "" }], "payable": true, "selector": "0xec0ab6a7", "stateMutability": "payable", "type": "function" });
 50 | }, TIMEOUT);
 51 | 
 52 | 
 53 | online_test('autoload full', async ({ provider, env }) => {
 54 |     const address = "0x4A137FD5e7a256eF08A7De531A17D0BE0cc7B6b6"; // Random unverified contract
 55 |     const { abi } = await autoload(address, {
 56 |         provider: provider,
 57 |         // Equivalent to:
 58 |         // ...whatsabi.loaders.defaultsWithEnv(env),
 59 |         abiLoader: new whatsabi.loaders.MultiABILoader([
 60 |             new whatsabi.loaders.SourcifyABILoader(),
 61 |             new whatsabi.loaders.EtherscanABILoader({ apiKey: env.ETHERSCAN_API_KEY }),
 62 |         ]),
 63 |         signatureLookup: new whatsabi.loaders.MultiSignatureLookup([
 64 |             new whatsabi.loaders.OpenChainSignatureLookup(),
 65 |             new whatsabi.loaders.FourByteSignatureLookup(),
 66 |         ]),
 67 |         //onProgress: (phase: string, ...args: any[]) => { console.debug("PROGRESS", phase, args); },
 68 |     });
 69 |     expect(abi).toContainEqual({
 70 |         "inputs": [
 71 |             { "type": "address" },
 72 |             { "type": "uint256" },
 73 |             { "type": "bytes" }
 74 |         ],
 75 |         "name": "call",
 76 |         "stateMutability": "nonpayable",
 77 |         "selector": "0x6dbf2fa0",
 78 |         "sig": "call(address,uint256,bytes)",
 79 |         "type": "function"
 80 |     });
 81 | 
 82 |     expect(abi).toContainEqual({ "selector": "0xec0ab6a7", "type": "function" });
 83 | }, TIMEOUT);
 84 | 
 85 | online_test('autoload non-contract', async ({ provider, env }) => {
 86 |     const address = "0x0000000000000000000000000000000000000000"; // Random unverified contract
 87 |     const { abi } = await autoload(address, {
 88 |         provider: provider,
 89 |         ...whatsabi.loaders.defaultsWithEnv(env),
 90 |     });
 91 |     expect(abi).toStrictEqual([]);
 92 | });
 93 | 
 94 | online_test('autoload verified multi', async ({ provider, env }) => {
 95 |     const address = "0x8f8ef111b67c04eb1641f5ff19ee54cda062f163"; // Uniswap v3 pool, verified on Etherscan and Sourcify
 96 |     const result = await autoload(address, {
 97 |         provider: provider,
 98 |         ...whatsabi.loaders.defaultsWithEnv(env),
 99 |     });
100 |     expect(result.abiLoadedFrom?.name).toBeTruthy();
101 | });
102 | 
103 | online_test('autoload loadContractResult verified etherscan', async ({ provider, env }) => {
104 |     const address = "0xc3d688b66703497daa19211eedff47f25384cdc3"; // Compound USDC proxy
105 |     const result = await autoload(address, {
106 |         provider: provider,
107 |         loadContractResult: true,
108 |         followProxies: false,
109 |         abiLoader: new whatsabi.loaders.EtherscanABILoader({ apiKey: env.ETHERSCAN_API_KEY }),
110 |     });
111 |     expect(result.abiLoadedFrom?.name).toBe("EtherscanABILoader");
112 |     expect(result.contractResult?.ok).toBeTruthy();
113 |     expect(result.contractResult?.name).toBe("TransparentUpgradeableProxy");
114 |     expect(result.contractResult?.compilerVersion).toBe("v0.8.15+commit.e14f2714");
115 |     expect(result.contractResult?.loaderResult?.Proxy).toBe("1");
116 |     expect(result.contractResult?.loaderResult?.Implementation).toMatch(new RegExp("^0x[0-9a-f]{40}

quot;));
117 | });
118 | 
119 | cached_test('autoload isFactory', async ({ provider, env, withCache }) => {
120 |     const address = "0x7dB8637A5fd20BbDab1176BdF49C943A96F2E9c6"; // Factory that makes proxies
121 | 
122 |     const code = await withCache(
123 |         `${address}_code`,
124 |         async () => {
125 |             return await provider.getCode(address)
126 |         },
127 |     )
128 |     const result = await autoload(address, {
129 |         provider: whatsabi.providers.WithCachedCode(provider, {
130 |             [address]: code,
131 |         }),
132 |         ...whatsabi.loaders.defaultsWithEnv(env),
133 |     });
134 |     expect(result.isFactory).toBeTruthy();
135 | });
136 | 
137 | cached_test('autoload ambiguous proxy', async ({ provider, env, withCache }) => {
138 |     // Issue #173
139 |     const address = "0xe1164a7a364929c3ba3da9671c8003dd71975d2d";
140 | 
141 |     const code = await withCache(
142 |         `${address}_code`,
143 |         async () => {
144 |             return await provider.getCode(address)
145 |         },
146 |     )
147 |     const result = await autoload(address, {
148 |         provider: whatsabi.providers.WithCachedCode(provider, {
149 |             [address]: code,
150 |         }),
151 |         ...whatsabi.loaders.defaultsWithEnv(env),
152 |     });
153 |     expect(result.proxies.length).toBe(1);
154 |     expect(result.followProxies).toBeFalsy();
155 | });
156 | 
157 | 


--------------------------------------------------------------------------------
/src/__tests__/disasm.test.ts:
--------------------------------------------------------------------------------
 1 | import { expect, test, describe } from 'vitest';
 2 | 
 3 | import { BytecodeIter } from "../disasm";
 4 | import { pushWidth } from "../opcodes";
 5 | 
 6 | describe('BytecodeIter', () => {
 7 |   test('opcodes', () => {
 8 |     const bytecode = "604260005260206000F3";
 9 |     // [00]	PUSH1	42
10 |     // [02]	PUSH1	00
11 |     // [04]	MSTORE
12 |     // [05]	PUSH1	20
13 |     // [07]	PUSH1	00
14 |     // [09]	RETURN
15 | 
16 |     const code = new BytecodeIter(bytecode, { bufferSize: 4 });
17 | 
18 |     expect(code.next()).toBe(0x60);
19 | 
20 |     expect(code.posBuffer.length).toBe(1);
21 |     expect(code.posBuffer[0]).toBe(0);
22 |     expect(pushWidth(code.bytecode[0])).toBe(1);
23 | 
24 |     expect(code.pos()).toBe(0);
25 |     expect(code.step()).toBe(0);
26 | 
27 |     expect(code.value()).toEqual(new Uint8Array([0x42]));
28 |     expect(code.next()).toBe(0x60);
29 | 
30 |     expect(code.pos()).toBe(2); // Pos goes up byte 2 because PUSH1
31 |     expect(code.step()).toBe(1);
32 | 
33 |     expect(code.value()).toEqual(new Uint8Array([0x00]));
34 |     expect(code.next()).toBe(0x52);
35 |     expect(code.next()).toBe(0x60);
36 |     expect(code.value()).toEqual(new Uint8Array([0x20]));
37 |     expect(code.next()).toBe(0x60);
38 |     expect(code.value()).toEqual(new Uint8Array([0x00]));
39 | 
40 |     // Relative peek back
41 |     expect(code.at(-1)).toBe(0x60);
42 |     expect(code.valueAt(-1)).toEqual(new Uint8Array([0x00]));
43 |     expect(code.at(-2)).toBe(0x60);
44 |     expect(code.valueAt(-2)).toEqual(new Uint8Array([0x20]));
45 |     expect(code.at(-3)).toBe(0x52);
46 |     expect(code.valueAt(-3)).toEqual(new Uint8Array());
47 |     expect(code.at(-4)).toBe(0x60);
48 | 
49 |     expect(code.hasMore()).toBe(true);
50 |     expect(code.next()).toBe(0xF3);
51 |     expect(code.hasMore()).toBe(false);
52 | 
53 |     expect(code.next()).toBe(0x00); // STOP, default value after hasMore is done
54 |   });
55 | 
56 |   test('buffer', () => {
57 |     const code = new BytecodeIter("604260005260206000F3", { bufferSize: 1 });
58 | 
59 |     // Exceed buffer
60 |     expect(code.at(-1)).toBe(undefined);
61 |     expect(code.at(-2)).toBe(undefined);
62 |     expect(code.valueAt(-1)).toEqual(new Uint8Array());
63 |     expect(code.at(-999)).toBe(undefined);
64 |     expect(code.valueAt(-999)).toEqual(new Uint8Array());
65 | 
66 |     expect(code.pos()).toBe(-1);
67 |     expect(code.step()).toBe(-1);
68 | 
69 |     expect(code.next()).toBe(0x60);
70 |     expect(code.at(-1)).toBe(0x60);
71 |     expect(code.valueAt(-1)).toEqual(new Uint8Array([0x42]));
72 |     expect(code.at(-2)).toBe(undefined);
73 | 
74 |     expect(code.pos()).toBe(0);
75 |     expect(code.step()).toBe(0);
76 | 
77 |     // Exceed bytecode
78 |     expect(code.at(999)).toBe(undefined);
79 |     expect(code.valueAt(999)).toEqual(new Uint8Array());
80 |   })
81 | });
82 | 


--------------------------------------------------------------------------------
/src/__tests__/edges.test.ts:
--------------------------------------------------------------------------------
  1 | import { expect, test } from 'vitest';
  2 | 
  3 | import { cached_test, describe_cached } from "./env";
  4 | import { selectorsFromBytecode } from '../index';
  5 | import { disasm } from '../disasm';
  6 | 
  7 | //const address = "0xbadc0defafcf6d4239bdf0b66da4d7bd36fcf05a";
  8 | //const missingSelector = "0x69277b67";
  9 | 
 10 | 
 11 | //const address = "0x00000000006c3852cbEf3e08E8dF289169EdE581";
 12 | //const extraSelector = "0x06fdde03";
 13 | 
 14 | //const address = "0x388c818ca8b9251b393131c08a736a67ccb19297"
 15 | //const missingSelectorJump = "0x8980f11f";
 16 | 
 17 | test('code with deploy init', () => {
 18 |   // https://github.com/shazow/whatsabi/issues/19#issuecomment-1498767496 
 19 |   const code = "60806040526000805534801561001457600080fd5b50610178806100246000396000f300608060405260043610610062576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806329e46078146100675780634e148ce11461009a57806368e5c066146100cd578063a87d942c146100e4575b600080fd5b34801561007357600080fd5b50610098600480360381019080803563ffffffff16906020019092919050505061010f565b005b3480156100a657600080fd5b506100cb600480360381019080803563ffffffff169060200190929190505050610122565b005b3480156100d957600080fd5b506100e2610135565b005b3480156100f057600080fd5b506100f9610143565b6040518082815260200191505060405180910390f35b8060020263ffffffff1660008190555050565b8060010263ffffffff1660008190555050565b600160005401600081905550565b600080549050905600a165627a7a72305820946aaa67044121e8026c839756e8dc0bcd00731a5c7239ace3524046974de6720029";
 20 | 
 21 |   const r = selectorsFromBytecode(code);
 22 |   r.sort();
 23 | 
 24 |   expect(r).toEqual(["0x29e46078", "0x4e148ce1", "0x68e5c066", "0xa87d942c"]);
 25 | })
 26 | 
 27 | test('code with non payable guard before router', () => {
 28 |   // https://github.com/shazow/whatsabi/issues/19#issuecomment-1500383369
 29 |   const code = "608060405234801561001057600080fd5b506004361061004c5760003560e01c806329e46078146100515780634e148ce11461008557806368e5c066146100b9578063a87d942c146100c3575b600080fd5b6100836004803603602081101561006757600080fd5b81019080803563ffffffff1690602001909291905050506100e1565b005b6100b76004803603602081101561009b57600080fd5b81019080803563ffffffff1690602001909291905050506100f4565b005b6100c1610107565b005b6100cb610115565b6040518082815260200191505060405180910390f35b8060020263ffffffff1660008190555050565b8060010263ffffffff1660008190555050565b600160005401600081905550565b6000805490509056fea26469706673582212204c69a9d6b5cb7799cdc0b4ac099047de21c79769b6be631679204f0e5bd74a0c64736f6c63430006000033";
 30 |   const r = selectorsFromBytecode(code);
 31 |   r.sort();
 32 | 
 33 |   expect(r).toEqual(["0x29e46078", "0x4e148ce1", "0x68e5c066", "0xa87d942c"]);
 34 | })
 35 | 
 36 | test('code with immutable in solidity', () => {
 37 |   // Via https://twitter.com/RenanRSouza35/status/1644308118375915523
 38 |   /*
 39 |     contract Foo {
 40 |         uint public immutable a;
 41 | 
 42 |         constructor(uint _a) {
 43 |             a = _a;
 44 |         }
 45 |     }
 46 |   */
 47 |   const code = "60a060405234801561001057600080fd5b506040516101913803806101918339818101604052810190610032919061007b565b8060808181525050506100a8565b600080fd5b6000819050919050565b61005881610045565b811461006357600080fd5b50565b6000815190506100758161004f565b92915050565b60006020828403121561009157610090610040565b5b600061009f84828501610066565b91505092915050565b60805160d16100c060003960006049015260d16000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80630dbe671f14602d575b600080fd5b60336047565b604051603e91906082565b60405180910390f35b7f000000000000000000000000000000000000000000000000000000000000000081565b6000819050919050565b607c81606b565b82525050565b6000602082019050609560008301846075565b9291505056fea2646970667358fe1220fefe877c7ce1496f641a93e2d422be3341a5980ffe704ad09a703dbf0bb1656d64736f6c63430008110033";
 48 |   const r = selectorsFromBytecode(code);
 49 |   r.sort();
 50 | 
 51 |   expect(r).toEqual([
 52 |     "0x0dbe671f" // a()
 53 |   ]);
 54 | })
 55 | 
 56 | test('issue 42', () => {
 57 |   // https://github.com/shazow/whatsabi/issues/42
 58 |   // https://etherscan.io/address/0x37c6e59e1ae39d81828db1a8e8233d6b2afcb9a8
 59 |   const bytecode = "0x5b602960346000f073032be5d2772329c11a72dadb32ce03806bb26f0a3160005760006000600060003031335af15060006000f36000600060206000600073032be5d2772329c11a72dadb32ce03806bb26f0a5a6069600052f15033ff";
 60 |   const r = selectorsFromBytecode(bytecode);
 61 |   expect(r).toEqual([
 62 |   ]);
 63 | });
 64 | 
 65 | import { WANDERWING } from './__fixtures__/proxies';
 66 | test('issue 67', () => {
 67 |   const bytecode = WANDERWING;
 68 |   const r = selectorsFromBytecode(bytecode);
 69 |   expect(r).toEqual([
 70 |   ]);
 71 | });
 72 | 
 73 | cached_test('issue 70: negated selector', async ({ provider, withCache }) => {
 74 |   const address = "0x000000000090d2b159528c290616CF919B24e1d9";
 75 | 
 76 |   const code = await withCache(
 77 |     `${address}_code`,
 78 |     async () => {
 79 |       return await provider.getCode(address)
 80 |     },
 81 |   )
 82 | 
 83 |   const r = selectorsFromBytecode(code);
 84 |   expect(r).toEqual(expect.arrayContaining(["0xfd9f1e10"]))
 85 | });
 86 | 
 87 | cached_test('issue 146: duplicated events', async ({ provider, withCache }) => {
 88 |   const address = "0xd9db270c1b5e3bd161e8c8503c55ceabee709552";
 89 | 
 90 |   const code = await withCache(
 91 |     `${address}_code`,
 92 |     async () => {
 93 |       return await provider.getCode(address)
 94 |     },
 95 |   )
 96 | 
 97 |   const r = disasm(code);
 98 |   expect(Array.from(r.eventCandidates).length).toEqual(14);
 99 | });
100 | 
101 | test('issue 171: immutable EIP1967 proxy', () => {
102 |   // https://github.com/shazow/whatsabi/issues/171
103 |   // createCode from https://etherscan.io/address/0x6f943318b05AD7c6EE596A220510A6D64B518dd8
104 |   const createCode = "60a06040526040516105bf3803806105bf83398101604081905261002291610387565b61002c828261003e565b506001600160a01b031660805261047e565b610047826100fe565b6040516001600160a01b038316907f1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e90600090a28051156100f2576100ed826001600160a01b0316635c60da1b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156100c3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100e79190610447565b82610211565b505050565b6100fa610288565b5050565b806001600160a01b03163b60000361013957604051631933b43b60e21b81526001600160a01b03821660048201526024015b60405180910390fd5b807fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d5080546001600160a01b0319166001600160a01b0392831617905560408051635c60da1b60e01b81529051600092841691635c60da1b9160048083019260209291908290030181865afa1580156101b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d99190610447565b9050806001600160a01b03163b6000036100fa57604051634c9c8ce360e01b81526001600160a01b0382166004820152602401610130565b6060600080846001600160a01b03168460405161022e9190610462565b600060405180830381855af49150503d8060008114610269576040519150601f19603f3d011682016040523d82523d6000602084013e61026e565b606091505b50909250905061027f8583836102a9565b95945050505050565b34156102a75760405163b398979f60e01b815260040160405180910390fd5b565b6060826102be576102b982610308565b610301565b81511580156102d557506001600160a01b0384163b155b156102fe57604051639996b31560e01b81526001600160a01b0385166004820152602401610130565b50805b9392505050565b8051156103185780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b80516001600160a01b038116811461034857600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561037e578181015183820152602001610366565b50506000910152565b6000806040838503121561039a57600080fd5b6103a383610331565b60208401519092506001600160401b03808211156103c057600080fd5b818501915085601f8301126103d457600080fd5b8151818111156103e6576103e661034d565b604051601f8201601f19908116603f0116810190838211818310171561040e5761040e61034d565b8160405282815288602084870101111561042757600080fd5b610438836020830160208801610363565b80955050505050509250929050565b60006020828403121561045957600080fd5b61030182610331565b60008251610474818460208701610363565b9190910192915050565b6080516101276104986000396000601e01526101276000f3fe6080604052600a600c565b005b60186014601a565b60a0565b565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316635c60da1b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156079573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190609b919060c3565b905090565b3660008037600080366000845af43d6000803e80801560be573d6000f35b3d6000fd5b60006020828403121560d457600080fd5b81516001600160a01b038116811460ea57600080fd5b939250505056fea2646970667358221220ba4584e06302b35e8111d9457f4e63fa0ab53461d8999af0dbc529c45465719264736f6c6343000819003300000000000000000000000028e06ce6b25529e736d45aff7c82ef4fc6f710be000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001a4fab57b8f0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000bdc312acd6b13f28d3a17c87a07b93d056a3236d00000000000000000000000074d9fb2b522cf886872ac333480dc4779a4bb21400000000000000000000000017e49fe369062d1eeca9564e5451021da778739b0000000000000000000000007e39183cda5af65e6a18af8c3bf0c523127f83bf000000000000000000000000604ffe37a969042c86ff0b10b2d2c4ea987d6f1d0000000000000000000000002c610e4c3c4bd4d6b76d4c7ce5e376b865c35660000000000000000000000000135dda560e946695d6f155dacafc6f1f25c1f5af000000000000000000000000bfef6e99e7dd8538ae9741d91ce27a486948aa8200000000000000000000000000000000000000000000000000000000000001400000000000000000000000004368f8f944430519f2222b0458f48ad287a83230000000000000000000000000000000000000000000000000000000000000001972656473746f6e652d6176732d6d61696e6e65742d626173650000000000000000000000000000000000000000000000000000000000000000000000";
105 |   const r = disasm(createCode);
106 |   expect(r.init).toBeDefined();
107 |   expect(r.init?.proxies.length).toBeGreaterThan(0);
108 |   expect(r.proxies.length).toBeGreaterThan(0);
109 |   expect(r.proxies[0].name).toEqual("EIP1967Proxy");
110 | });
111 | 
112 | // Addresses with false positive zero selectors:
113 | // 0x99aa182ed0e2b6c47132e95686d2c73cdeff307f
114 | // 0xb1116d0a09f06d3e22a264c0c233d80e93abec10
115 | // 0xb60e36e2d67a34b4eae678cad779e281e4c6d58c
116 | 


--------------------------------------------------------------------------------
/src/__tests__/env.ts:
--------------------------------------------------------------------------------
 1 | import { test, describe } from 'vitest';
 2 | 
 3 | import { ethers } from "ethers";
 4 | import { createPublicClient, createWalletClient, http } from 'viem';
 5 | import { Web3 } from "web3";
 6 | 
 7 | import { withCache } from "../internal/filecache";
 8 | import { CompatibleProvider, Provider } from "../providers.js";
 9 | 
10 | const env = {
11 |     INFURA_API_KEY: process.env.INFURA_API_KEY,
12 |     ETHERSCAN_API_KEY: process.env.ETHERSCAN_API_KEY,
13 | 
14 |     PROVIDER: process.env.PROVIDER,
15 |     PROVIDER_RPC_URL: process.env.PROVIDER_RPC_URL,
16 | };
17 | 
18 | const DEFAULT_PUBLIC_RPC = "https://ethereum-rpc.publicnode.com";
19 | 
20 | 
21 | /**
22 |  * Make a CompatibleProvider for testing relative to the environment we're testing against.
23 |  */
24 | export function makeProvider(rpc_url?: string): Provider {
25 |     return CompatibleProvider(function() {
26 |         if (!rpc_url) {
27 |             if (env.INFURA_API_KEY) {
28 |                 rpc_url = "https://mainnet.infura.io/v3/" + env.INFURA_API_KEY;
29 |             } else {
30 |                 rpc_url = env.PROVIDER_RPC_URL;
31 |             }
32 |         }
33 | 
34 |         if (env.PROVIDER?.startsWith("viem")) {
35 |             const transport = http(rpc_url ?? DEFAULT_PUBLIC_RPC);
36 |             if (env.PROVIDER.endsWith("publicClient")) return createPublicClient({ transport });
37 |             if (env.PROVIDER.endsWith("transport")) return transport({});
38 |             return createWalletClient({ transport });
39 |         }
40 | 
41 |         if (env.PROVIDER === "web3") {
42 |             return new Web3(rpc_url ?? DEFAULT_PUBLIC_RPC);
43 |         }
44 | 
45 |         if (!env.PROVIDER || env.PROVIDER === "ethers") {
46 |             if (rpc_url) return new ethers.JsonRpcProvider(rpc_url);
47 |             if (env.INFURA_API_KEY) return new ethers.InfuraProvider("homestead", env.INFURA_API_KEY);
48 |             return new ethers.JsonRpcProvider(DEFAULT_PUBLIC_RPC);
49 |         }
50 | 
51 |         throw new Error("Unknown PROVIDER: " + env.PROVIDER);
52 |     }());
53 | }
54 | 
55 | const provider = makeProvider();
56 | 
57 | type ItConcurrent = typeof test.skip;
58 | 
59 | type TestWithContext = (
60 |     name: string,
61 |     fn: (context: any) => void,
62 |     timeout?: number
63 | ) => void;
64 | 
65 | // TODO: Switch to using test.extend? https://vitest.dev/api/#test-extend
66 | 
67 | function testerWithContext(tester: ItConcurrent, context: any): TestWithContext {
68 |     return (name, fn, timeout) => tester(name, () => fn(context), timeout);
69 | }
70 | 
71 | export function describe_cached(d: string, fn: (context: any) => void) {
72 |     return describe(d, () => fn({ provider, env, withCache }));
73 | }
74 | 
75 | // TODO: Port this to context-aware wrapper
76 | export const online_test = testerWithContext(process.env["ONLINE"] ? test : test.skip, { provider, env });
77 | export const cached_test = testerWithContext(!process.env["SKIP_CACHED"] ? test : test.skip, { provider, env, withCache });
78 | export { test };
79 | 
80 | if (process.env["ONLINE"] === undefined) {
81 |     console.log("Skipping online tests. Set ONLINE env to run them.");
82 | }
83 | 


--------------------------------------------------------------------------------
/src/__tests__/examples.test.ts:
--------------------------------------------------------------------------------
  1 | import { expect } from 'vitest';
  2 | 
  3 | import { whatsabi } from "../index";
  4 | 
  5 | import { cached_test, online_test } from "./env";
  6 | 
  7 | const TIMEOUT = 25000;
  8 | 
  9 | cached_test('README usage', async ({ provider, withCache }) => {
 10 | 
 11 |     const address = "0x00000000006c3852cbEf3e08E8dF289169EdE581"; // Or your fav contract address
 12 | 
 13 |     const code = await withCache(
 14 |         `${address}_code`,
 15 |         async () => {
 16 |             return await provider.getCode(address)
 17 |         },
 18 |     )
 19 | 
 20 |     const selectors = whatsabi.selectorsFromBytecode(code); // Get the callable selectors
 21 | 
 22 |     // console.log(selectors); // ["0x06fdde03", "0x46423aa7", "0x55944a42", ...]
 23 |     expect(selectors).toEqual(expect.arrayContaining(["0x06fdde03", "0x46423aa7", "0x55944a42"]));
 24 | 
 25 |     {
 26 |         const abi = whatsabi.abiFromBytecode(code);
 27 |         // console.log(abi);
 28 |         // [
 29 |         //        {"type": "event", "hash": "0x721c20121297512b72821b97f5326877ea8ecf4bb9948fea5bfcb6453074d37f"},
 30 |         //        {"type": "function", "payable": true, "selector": "0x06fdde03"},
 31 |         //        {"type": "function", "payable": true, "selector": "0x46423aa7"},
 32 |         //        ...
 33 |         // ]
 34 | 
 35 |         expect(abi).toContainEqual({ "hash": "0x721c20121297512b72821b97f5326877ea8ecf4bb9948fea5bfcb6453074d37f", "type": "event" });
 36 |         expect(abi).toContainEqual(
 37 |             { "payable": true, "selector": "0xb3a34c4c", "type": "function", "stateMutability": "payable", "inputs": [{ "type": "bytes", "name": "" }], "outputs": [{ "type": "bytes", "name": "" }] },
 38 |         );
 39 |     }
 40 | 
 41 |     const signatureLookup = new whatsabi.loaders.OpenChainSignatureLookup();
 42 |     {
 43 |         const sig = await signatureLookup.loadFunctions("0x06fdde03");
 44 |         expect(sig).toStrictEqual(["name()"]);
 45 |     }
 46 |     {
 47 |         const sig = await signatureLookup.loadFunctions("0x46423aa7");
 48 |         expect(sig).toStrictEqual(["getOrderStatus(bytes32)"]);
 49 |     }
 50 | 
 51 |     const event = await signatureLookup.loadEvents("0x721c20121297512b72821b97f5326877ea8ecf4bb9948fea5bfcb6453074d37f");
 52 |     expect(event).toContainEqual("CounterIncremented(uint256,address)")
 53 | }, TIMEOUT)
 54 | 
 55 | online_test('README autoload', async ({ provider }) => {
 56 |     const address = "0x00000000006c3852cbEf3e08E8dF289169EdE581"; // Or your fav contract address
 57 | 
 58 |     {
 59 |         let result = await whatsabi.autoload(address, {
 60 |             provider: provider,
 61 | 
 62 |             // * Optional loaders:
 63 |             // abiLoader: whatsabi.loaders.defaultABILoader,
 64 |             // signatureLoader: whatsabi.loaders.defaultSignatureLookup,
 65 | 
 66 |             // There is a handy helper for adding the default loaders but with your own settings
 67 |             ...whatsabi.loaders.defaultsWithEnv({
 68 |                 SOURCIFY_CHAIN_ID: 42161,
 69 |                 ETHERSCAN_BASE_URL: "https://api.arbiscan.io/api",
 70 |                 //ETHERSCAN_API_KEY: "MYSECRETAPIKEY",
 71 |             }),
 72 | 
 73 |             // * Optional hooks:
 74 |             // onProgress: (phase: string) => { ... }
 75 |             // onError: (phase: string, context: any) => { ... }
 76 | 
 77 |             onProgress: (phase) => console.log("autoload progress", phase),
 78 |             onError: (phase, context) => console.log("autoload error", phase, context),
 79 | 
 80 |             // * Optional settings:
 81 |             // followProxies: false,
 82 |             // enableExperimentalMetadata: false,
 83 |         });
 84 |         expect(result.abi).toContainEqual(
 85 |             // 'function name() pure returns (string contractName)'
 86 |             { "inputs": [], "name": "name", "outputs": [{ "internalType": "string", "name": "contractName", "type": "string" }], "stateMutability": "pure", "type": "function" }
 87 |         );
 88 | 
 89 |         if (result.followProxies) {
 90 |             result = await result.followProxies();
 91 |         }
 92 |     }
 93 | 
 94 |     {
 95 |         const { abi, address } = await whatsabi.autoload("0x4f8AD938eBA0CD19155a835f617317a6E788c868", {
 96 |             provider,
 97 |             followProxies: true,
 98 |         });
 99 |         expect(abi.length).toBeGreaterThan(0);
100 |         expect(address).toBe("0x964f84048f0d9bb24b82413413299c0a1d61ea9f");
101 |     }
102 | 
103 |     {
104 |         // Check defaultsWithEnv decomposition
105 |         const { abiLoader, signatureLookup } = whatsabi.loaders.defaultsWithEnv({});
106 |         expect(abiLoader).toBeDefined();
107 |         expect(signatureLookup).toBeDefined();
108 |     }
109 | 
110 | }, TIMEOUT);
111 | 


--------------------------------------------------------------------------------
/src/__tests__/index.test.ts:
--------------------------------------------------------------------------------
 1 | import { expect, test } from 'vitest';
 2 | 
 3 | import { ethers } from "ethers";
 4 | 
 5 | import { SAMPLE_CODE, SAMPLE_ABI } from "./__fixtures__/sample";
 6 | 
 7 | import { selectorsFromBytecode, selectorsFromABI, abiFromBytecode } from '../index';
 8 | import {ABIFunction} from '../abi';
 9 | 
10 | test('selectorsFromBytecode', () => {
11 |   const abi = selectorsFromABI(SAMPLE_ABI)
12 |   const expected = Object.keys(abi);
13 | 
14 |   const r = selectorsFromBytecode(SAMPLE_CODE);
15 |   expect(new Set(r)).toStrictEqual(new Set(expected));
16 | });
17 | 
18 | test.skip('WIP: abiFromBytecode functions', () => {
19 |   const r = abiFromBytecode(SAMPLE_CODE).filter(a => a.type === "function") as ABIFunction[];
20 |   const got = Object.fromEntries(r.map(a=> [a.selector, a]));
21 |   const sample = toKnown(SAMPLE_ABI.filter(a => a.type === "function"));
22 |   const expected = Object.fromEntries(sample.map(a => {
23 |     if (got[a.selector] !== undefined) {
24 |       (got[a.selector] as any).name = a.name;
25 |     }
26 |     return [a.selector, a]
27 |   }))
28 | 
29 |   expect(
30 |     got
31 |   ).toStrictEqual(
32 |     expected
33 |   );
34 | });
35 | 
36 | // toKnown converts a traditional ABI object to a subset that we know how to
37 | // extract, so that we can make comparisons within our limitations.
38 | function toKnown(abi: any[]) {
39 |   const iface = new ethers.Interface(abi);
40 | 
41 |   return abi.map(a => {
42 |     if (a.type === "event") {
43 |       return a;
44 |     }
45 |     if (a.type === "function") {
46 |       a.selector = iface.getFunction(a.name)?.selector;
47 |     }
48 | 
49 |     // We can only tell iff there are inputs/outputs, not what they are
50 |     if (a.inputs.length > 0) a.inputs = [{type: "bytes"}];
51 |     else delete(a["inputs"]);
52 | 
53 |     if (a.outputs.length > 0) a.outputs = [{type: "bytes"}];
54 |     else delete(a["outputs"]);
55 | 
56 |     delete(a["anonymous"]);
57 | 
58 |     a.payable = a.stateMutability === "payable";
59 | 
60 |     return a;
61 |   })
62 | }
63 | 


--------------------------------------------------------------------------------
/src/__tests__/interfaces.test.ts:
--------------------------------------------------------------------------------
 1 | import { expect, test } from 'vitest';
 2 | 
 3 | import { abiToInterfaces, createInterfaceIndex } from '../interfaces';
 4 | 
 5 | 
 6 | test('createInterfaceIndex', async ({ }) => {
 7 |     const known = {
 8 |         "ERC-20": [
 9 |             "function totalSupply() view returns (uint256)",
10 |             "function balanceOf(address) view returns (uint256)",
11 |             "function transfer(address, uint256) returns (bool)",
12 |             "function allowance(address, address) returns (uint256)",
13 |             "function approve(address, uint256) returns (bool)",
14 |             "function transferFrom(address, address, uint256) returns (bool)",
15 |         ],
16 |     };
17 | 
18 |     const got = createInterfaceIndex(known);
19 |     expect(got).toEqual({
20 |         "ERC-20": new Set([
21 |             "18160ddd",
22 |             "70a08231",
23 |             "a9059cbb",
24 |             "dd62ed3e",
25 |             "095ea7b3",
26 |             "23b872dd",
27 |         ]),
28 |     });
29 | 
30 | });
31 | 
32 | test('abiToInterfaces', async ({ }) => {
33 |     // Given a set of interfaces, get the interfaces that it implements
34 |     const selectors = [
35 |         // bunch of stuff
36 |         "0x02751cec", "0x054d50d4", "0x18cbafe5", "0x1f00ca74", "0x2195995c", "0x38ed1739", "0x4a25d94a", "0x5b0d5984", "0x5c11d795", "0x791ac947", "0x7ff36ab5", "0x85f8c259", "0x8803dbee", "0xad5c4648", "0xad615dec", "0xaf2979eb", "0xb6f9de95", "0xbaa2abde", "0xc45a0155", "0xd06ca61f", "0xded9382a", "0xe8e33700", "0xf305d719", "0xfb3bdb41",
37 | 
38 |         // erc20
39 |         "0x18160ddd", "0x70a08231", "0xa9059cbb", "0xdd62ed3e", "0x095ea7b3", "0x23b872dd",
40 | 
41 |         // erc165, no 0x prefix
42 |         "01ffc9a7"
43 |     ];
44 | 
45 |     const got = abiToInterfaces(selectors);
46 |     expect(got).toEqual(["ERC-20", "ERC-165"]);
47 | });
48 | 
49 | test('abiToInterfaces with signatures', async ({ }) => {
50 |     const sigs = [
51 |         "function totalSupply() view returns (uint256)",
52 |         "function balanceOf(address) view returns (uint256)",
53 |         "function transfer(address, uint256) returns (bool)",
54 |         "function allowance(address, address) returns (uint256)",
55 |         "function approve(address, uint256) returns (bool)",
56 |         "function transferFrom(address, address, uint256) returns (bool)",
57 |     ];
58 | 
59 |     const got = abiToInterfaces(sigs);
60 |     expect(got).toEqual(["ERC-20"]);
61 | });
62 | 
63 | 


--------------------------------------------------------------------------------
/src/__tests__/loaders.test.ts:
--------------------------------------------------------------------------------
  1 | import { expect, describe } from 'vitest';
  2 | 
  3 | import {
  4 |   defaultABILoader,
  5 |   defaultSignatureLookup,
  6 | 
  7 |   SourcifyABILoader,
  8 |   EtherscanABILoader,
  9 |   EtherscanV2ABILoader,
 10 |   BlockscoutABILoader,
 11 |   AnyABILoader,
 12 |   MultiABILoader,
 13 | 
 14 |   OpenChainSignatureLookup,
 15 |   SamczunSignatureLookup,
 16 |   FourByteSignatureLookup,
 17 | } from "../loaders";
 18 | import type {
 19 |   ABILoader
 20 | } from "../loaders";
 21 | 
 22 | import { selectorsFromABI } from "../index";
 23 | 
 24 | import { describe_cached, online_test, test } from "./env";
 25 | 
 26 | const SLOW_ETHERSCAN_TIMEOUT = 30000;
 27 | 
 28 | describe('loaders: ABILoader', () => {
 29 |   online_test('defaultABILoader', async () => {
 30 |     const addr = "0x7a250d5630b4cf539739df2c5dacb4c659f2488d";
 31 |     const abi = await defaultABILoader.loadABI(addr);
 32 |     const selectors = selectorsFromABI(abi);
 33 |     const hashes = Object.keys(selectors);
 34 |     hashes.sort();
 35 |     expect(hashes).toStrictEqual(['0x02751cec', '0x054d50d4', '0x18cbafe5', '0x1f00ca74', '0x2195995c', '0x38ed1739', '0x4a25d94a', '0x5b0d5984', '0x5c11d795', '0x791ac947', '0x7ff36ab5', '0x85f8c259', '0x8803dbee', '0xad5c4648', '0xad615dec', '0xaf2979eb', '0xb6f9de95', '0xbaa2abde', '0xc45a0155', '0xd06ca61f', '0xded9382a', '0xe8e33700', '0xf305d719', '0xfb3bdb41']);
 36 | 
 37 |     expect(selectors["0x7ff36ab5"]).toStrictEqual("swapExactETHForTokens(uint256,address[],address,uint256)");
 38 |   });
 39 | 
 40 |   online_test('SourcifyABILoader', async () => {
 41 |     const loader = new SourcifyABILoader();
 42 |     const abi = await loader.loadABI("0x7a250d5630b4cf539739df2c5dacb4c659f2488d"); // Unchecksummed address
 43 |     const selectors = Object.values(selectorsFromABI(abi));
 44 |     const sig = "swapExactETHForTokens(uint256,address[],address,uint256)";
 45 |     expect(selectors).toContain(sig);
 46 |   })
 47 | 
 48 |   online_test('EtherscanABILoader', async ({ env }) => {
 49 |     const loader = new EtherscanABILoader({ apiKey: env["ETHERSCAN_API_KEY"] });
 50 |     const abi = await loader.loadABI("0x7a250d5630b4cf539739df2c5dacb4c659f2488d");
 51 |     const selectors = Object.values(selectorsFromABI(abi));
 52 |     const sig = "swapExactETHForTokens(uint256,address[],address,uint256)";
 53 |     expect(selectors).toContain(sig);
 54 |   }, SLOW_ETHERSCAN_TIMEOUT)
 55 | 
 56 |   online_test('BlockscoutABILoader', async ({ env }) => {
 57 |     const loader = new BlockscoutABILoader({
 58 |       apiKey: env["BLOCKSCOUT_API_KEY"],
 59 |     });
 60 |     const abi = await loader.loadABI("0x7a250d5630b4cf539739df2c5dacb4c659f2488d");
 61 |     const selectors = Object.values(selectorsFromABI(abi));
 62 |     const sig = "swapExactETHForTokens(uint256,address[],address,uint256)";
 63 |     expect(selectors).toContain(sig);
 64 |   })
 65 | 
 66 |   online_test('MultiABILoader', async ({ env }) => {
 67 |     // A contract that is verified on etherscan but not sourcify
 68 |     const address = "0xa9a57f7d2A54C1E172a7dC546fEE6e03afdD28E2";
 69 |     const loader = new MultiABILoader([
 70 |       new SourcifyABILoader(),
 71 |       new EtherscanABILoader({ apiKey: env["ETHERSCAN_API_KEY"] }),
 72 |     ]);
 73 |     const abi = await loader.loadABI(address);
 74 |     const sig = "getMagistrate()";
 75 |     const selectors = Object.values(selectorsFromABI(abi));
 76 |     expect(selectors).toContain(sig);
 77 |   }, SLOW_ETHERSCAN_TIMEOUT);
 78 | 
 79 |   online_test('SourcifyABILoader_getContract', async () => {
 80 |     const loader = new SourcifyABILoader();
 81 |     const result = await loader.getContract("0x7a250d5630b4cf539739df2c5dacb4c659f2488d");
 82 |     const selectors = Object.values(selectorsFromABI(result.abi));
 83 |     const sig = "swapExactETHForTokens(uint256,address[],address,uint256)";
 84 |     expect(selectors).toContain(sig);
 85 |     expect(result.name).toStrictEqual("UniswapV2Router02")
 86 |     expect(result.loader?.name).toStrictEqual("SourcifyABILoader");
 87 |     expect(result.loaderResult?.output?.userdoc).toBeDefined();
 88 |     expect(result.loaderResult?.output?.devdoc).toBeDefined();
 89 |   })
 90 | 
 91 |   online_test('SourcifyABILoader_getContract_UniswapV3Factory', async () => {
 92 |     const loader = new SourcifyABILoader();
 93 |     const { abi, name } = await loader.getContract("0x1F98431c8aD98523631AE4a59f267346ea31F984");
 94 |     const selectors = Object.values(selectorsFromABI(abi));
 95 |     const sig = "owner()";
 96 |     expect(selectors).toContain(sig);
 97 |     expect(name).toEqual("Canonical Uniswap V3 factory");
 98 |   })
 99 | 
100 |   online_test('EtherscanABILoader_getContract', async ({ env }) => {
101 |     const loader = new EtherscanABILoader({ apiKey: env["ETHERSCAN_API_KEY"] });
102 |     const result = await loader.getContract("0x7a250d5630b4cf539739df2c5dacb4c659f2488d");
103 |     const selectors = Object.values(selectorsFromABI(result.abi));
104 |     const sig = "swapExactETHForTokens(uint256,address[],address,uint256)";
105 |     expect(selectors).toContain(sig);
106 | 
107 |     const sources = result.getSources && await result.getSources();
108 |     expect(sources && sources[0].content).toContain("pragma solidity");
109 | 
110 |   }, SLOW_ETHERSCAN_TIMEOUT)
111 | 
112 |   online_test('EtherscanABILoader_getContract_UniswapV3Factory', async ({ env }) => {
113 |     const loader = new EtherscanABILoader({ apiKey: env["ETHERSCAN_API_KEY"] });
114 |     const { abi, name } = await loader.getContract("0x1F98431c8aD98523631AE4a59f267346ea31F984");
115 |     const selectors = Object.values(selectorsFromABI(abi));
116 |     const sig = "owner()";
117 |     expect(selectors).toContain(sig);
118 |     expect(name).toEqual("UniswapV3Factory");
119 |   }, SLOW_ETHERSCAN_TIMEOUT)
120 | 
121 |   online_test('EtherscanABILoader_getContract_CompoundUSDCProxy', async ({ env }) => {
122 |     const loader = new EtherscanABILoader({ apiKey: env["ETHERSCAN_API_KEY"] });
123 |     const result = await loader.getContract("0xc3d688b66703497daa19211eedff47f25384cdc3");
124 |     expect(result.name).toEqual("TransparentUpgradeableProxy");
125 |     expect(result.loaderResult?.Proxy).toBeTruthy();
126 |     expect(result.loaderResult?.Implementation).toMatch(/^0x[0-9a-f]{40}$/);
127 |   }, SLOW_ETHERSCAN_TIMEOUT)
128 | 
129 |   online_test('BlockscoutABILoader_getContract', async ({ env }) => {
130 |     const loader = new BlockscoutABILoader({
131 |       apiKey: env["BLOCKSCOUT_API_KEY"],
132 |     });
133 |     const result = await loader.getContract("0x7a250d5630b4cf539739df2c5dacb4c659f2488d");
134 |     const selectors = Object.values(selectorsFromABI(result.abi));
135 |     const sig = "swapExactETHForTokens(uint256,address[],address,uint256)";
136 |     expect(selectors).toContain(sig);
137 |     expect(result.name).toStrictEqual("UniswapV2Router02")
138 |     expect(result.loader?.name).toStrictEqual("BlockscoutABILoader");
139 |     expect(result.loaderResult?.source_code).toBeDefined();
140 |     expect(result.loaderResult?.compiler_settings).toBeDefined();
141 | 
142 |     const sources = result.getSources && await result.getSources();
143 |     expect(sources && sources[0].content).toContain("pragma solidity");
144 |   })
145 | 
146 |   online_test('BlockscoutABILoader_getContract_UniswapV3Factory', async ({ env }) => {
147 |     const loader = new BlockscoutABILoader({
148 |       apiKey: env["BLOCKSCOUT_API_KEY"],
149 |     });
150 |     const { abi, name } = await loader.getContract("0x1F98431c8aD98523631AE4a59f267346ea31F984");
151 |     const selectors = Object.values(selectorsFromABI(abi));
152 |     const sig = "owner()";
153 |     expect(selectors).toContain(sig);
154 |     expect(name).toEqual("UniswapV3Factory");
155 |   })
156 | 
157 |   online_test('MultiABILoader_getContract', async ({ env }) => {
158 |     // A contract that is verified on etherscan but not sourcify
159 |     const address = "0xa9a57f7d2A54C1E172a7dC546fEE6e03afdD28E2";
160 |     const loader = new MultiABILoader([
161 |       new SourcifyABILoader(),
162 |       new EtherscanABILoader({ apiKey: env["ETHERSCAN_API_KEY"] }),
163 |     ]);
164 |     const result = await loader.getContract(address);
165 |     const sig = "getMagistrate()";
166 |     const selectors = Object.values(selectorsFromABI(result.abi));
167 |     expect(selectors).toContain(sig);
168 |     expect(result.name).toEqual("KetherSortition");
169 |     expect(result.loader?.name).toStrictEqual(EtherscanABILoader.name);
170 |   }, SLOW_ETHERSCAN_TIMEOUT);
171 | 
172 |   online_test('MultiABILoader_getContract_UniswapV3Factory', async ({ env }) => {
173 |     const address = "0x1F98431c8aD98523631AE4a59f267346ea31F984";
174 |     const loader = new MultiABILoader([
175 |       new SourcifyABILoader(),
176 |       new EtherscanABILoader({ apiKey: env["ETHERSCAN_API_KEY"] }),
177 |     ]);
178 |     const { abi, name } = await loader.getContract(address);
179 |     const sig = "owner()";
180 |     const selectors = Object.values(selectorsFromABI(abi));
181 |     expect(selectors).toContain(sig);
182 |     expect(name).toEqual("Canonical Uniswap V3 factory");
183 |   }, SLOW_ETHERSCAN_TIMEOUT);
184 | 
185 |   online_test('MultiABILoader_SourcifyOnly_getContract_UniswapV3Factory', async () => {
186 |     const address = "0x1F98431c8aD98523631AE4a59f267346ea31F984";
187 |     const loader = new MultiABILoader([
188 |       new SourcifyABILoader(),
189 |     ]);
190 |     const result = await loader.getContract(address);
191 |     const sig = "owner()";
192 |     const selectors = Object.values(selectorsFromABI(result.abi));
193 |     expect(selectors).toContain(sig);
194 |     expect(result.name).toEqual("Canonical Uniswap V3 factory");
195 |     expect(result.loader?.name).toStrictEqual(SourcifyABILoader.name);
196 |     expect(result.loaderResult?.output?.userdoc).toBeDefined();
197 |     expect(result.loaderResult?.output?.devdoc).toBeDefined();
198 |   }, SLOW_ETHERSCAN_TIMEOUT);
199 | 
200 |   online_test('MultiABILoader_EtherscanOnly_getContract_UniswapV3Factory', async ({ env }) => {
201 |     const address = "0x1F98431c8aD98523631AE4a59f267346ea31F984";
202 |     const loader = new MultiABILoader([
203 |       new EtherscanABILoader({ apiKey: env["ETHERSCAN_API_KEY"] }),
204 |     ]);
205 |     const res = await loader.getContract(address);
206 |     const sig = "owner()";
207 |     const selectors = Object.values(selectorsFromABI(res.abi));
208 |     expect(selectors).toContain(sig);
209 |     expect(res.name).toEqual("UniswapV3Factory");
210 | 
211 |     const sources = res.getSources && await res.getSources();
212 |     expect(
213 |       sources?.find(s => s.path?.endsWith("contracts/libraries/UnsafeMath.sol"))?.content
214 |     ).contains("pragma solidity");
215 |   }, SLOW_ETHERSCAN_TIMEOUT);
216 | });
217 | 
218 | describe_cached("loaders: ABILoader suite", async ({ env }) => {
219 |   // Addess we know won't have a verified ABI 
220 |   const knownUnverified = "0x0000000000000000000000000000000000000001";
221 | 
222 |   function makeTest(loader: ABILoader, knownVerified: string) {
223 |     online_test(`${loader.name} unverified getContract`, async () => {
224 |       const r = await loader.getContract(knownUnverified);
225 |       expect(r.ok).toBeFalsy();
226 |       expect(r.abi).toStrictEqual([]);
227 |     });
228 | 
229 |     online_test(`${loader.name} unverified loadABI`, async () => {
230 |       const r = await loader.loadABI(knownUnverified);
231 |       expect(r).toStrictEqual([]);
232 |     });
233 | 
234 |     online_test(`${loader.name} verified getContract`, async () => {
235 |       const r = await loader.getContract(knownVerified);
236 |       expect(r.ok).toBeTruthy();
237 |       expect(r.abi).not.toStrictEqual([]);
238 |     });
239 |   }
240 | 
241 |   const uniswapV2Router = "0x7a250d5630b4cf539739df2c5dacb4c659f2488d";
242 | 
243 |   const loaders = [
244 |     new SourcifyABILoader(),
245 |     new EtherscanABILoader({ apiKey: env["ETHERSCAN_API_KEY"] }),
246 |     new EtherscanV2ABILoader({ apiKey: env["ETHERSCAN_API_KEY"] }),
247 |     new BlockscoutABILoader({ apiKey: env["BLOCKSCOUT_API_KEY"] }),
248 |     new AnyABILoader(),
249 |   ];
250 | 
251 |   for (const loader of loaders) {
252 |     makeTest(loader, uniswapV2Router);
253 |   }
254 | 
255 |   makeTest(new MultiABILoader(loaders), uniswapV2Router);
256 | });
257 | 
258 | 
259 | describe('loaders: SignatureLookup', () => {
260 |   online_test('defaultSignatureLookup', async () => {
261 |     const sig = "swapExactETHForTokens(uint256,address[],address,uint256)";
262 |     const selector = "0x7ff36ab5"
263 |     const selectors = selectorsFromABI([sig]);
264 |     expect(Object.keys(selectors)).toContain(selector);
265 | 
266 |     const r = await defaultSignatureLookup.loadFunctions(selector);
267 |     expect(r).toContain(sig);
268 |   });
269 | 
270 |   online_test('SamczunSignatureLookup', async () => {
271 |     const lookup = new SamczunSignatureLookup();
272 |     const selectors = await lookup.loadFunctions("0x7ff36ab5");
273 |     const sig = "swapExactETHForTokens(uint256,address[],address,uint256)";
274 |     expect(selectors).toContain(sig);
275 |   })
276 | 
277 |   online_test('OpenChainSignatureLookup', async () => {
278 |     const lookup = new OpenChainSignatureLookup();
279 |     const selectors = await lookup.loadFunctions("0x7ff36ab5");
280 |     const sig = "swapExactETHForTokens(uint256,address[],address,uint256)";
281 |     expect(selectors).toContain(sig);
282 |   })
283 | 
284 |   online_test('FourByteSignatureLookup', async () => {
285 |     const lookup = new FourByteSignatureLookup();
286 |     const selectors = await lookup.loadFunctions("0x7ff36ab5");
287 |     const sig = "swapExactETHForTokens(uint256,address[],address,uint256)";
288 |     expect(selectors).toContain(sig);
289 |   })
290 | });
291 | 
292 | 
293 | describe('loaders: helpers', () => {
294 |   test('SourcifyABILoader.stripPathPrefix', () => {
295 |     expect(
296 |       SourcifyABILoader.stripPathPrefix("/contracts/full_match/1/0x1F98431c8aD98523631AE4a59f267346ea31F984/sources/contracts/interfaces/IERC20Minimal.sol")
297 |     ).toEqual("contracts/interfaces/IERC20Minimal.sol");
298 | 
299 |     expect(
300 |       SourcifyABILoader.stripPathPrefix("/contracts/full_match/1/0x1F98431c8aD98523631AE4a59f267346ea31F984/metadata.json")
301 |     ).toEqual("metadata.json");
302 |   });
303 | });
304 | 


--------------------------------------------------------------------------------
/src/__tests__/providers.test.ts:
--------------------------------------------------------------------------------
 1 | import { expect } from 'vitest';
 2 | import { test } from "./env";
 3 | 
 4 | import { whatsabi } from "../index";
 5 | 
 6 | const fakeProvider = whatsabi.providers.CompatibleProvider({
 7 |     request: () => { },
 8 | });
 9 | 
10 | test('provider WithCachedCode with CompatibleProvider', async () => {
11 |     const address = "0x0000000000000000000000000000000000000001";
12 |     const provider = whatsabi.providers.WithCachedCode(fakeProvider, {
13 |         [address]: "0xf00",
14 |     });
15 | 
16 |     expect(await provider.getCode(address)).toStrictEqual("0xf00");
17 |     expect(await provider.getCode("not cached")).toBeUndefined();
18 | });
19 | 
20 | test('provider WithCachedCode with AnyProvider', async () => {
21 |     const anyProvider = {
22 |         request: () => { },
23 |     };
24 |     const address = "0x0000000000000000000000000000000000000001";
25 |     const provider = whatsabi.providers.WithCachedCode(anyProvider, {
26 |         [address]: "0xf00",
27 |     });
28 | 
29 |     expect(await provider.getCode(address)).toStrictEqual("0xf00");
30 |     expect(await provider.getCode("not cached")).toBeUndefined();
31 | });
32 | 


--------------------------------------------------------------------------------
/src/__tests__/proxies.test.ts:
--------------------------------------------------------------------------------
  1 | import { expect, describe, test } from 'vitest';
  2 | 
  3 | import { cached_test, online_test, makeProvider } from './env';
  4 | 
  5 | import { disasm } from '../disasm';
  6 | import { addSlotOffset, readArray, joinSlot } from "../slots.js";
  7 | import * as proxies from '../proxies';
  8 | 
  9 | import { ZEPPELINOS_USDC, WANDERWING } from './__fixtures__/proxies'
 10 | 
 11 | // TODO: Test for proxy factories to not match
 12 | 
 13 | describe('proxy detection', () => {
 14 |     test('Minimal Proxy Pattern', async () => {
 15 |         // https://eips.ethereum.org/EIPS/eip-1167
 16 |         // includes deploy instructions
 17 |         const bytecode = "0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3";
 18 | 
 19 |         const program = disasm(bytecode);
 20 |         expect(program.proxies[0]).toBeInstanceOf(proxies.FixedProxyResolver);
 21 |         const proxy = program.proxies[0] as proxies.FixedProxyResolver;
 22 |         expect(proxy.resolvedAddress).toBe("0xbebebebebebebebebebebebebebebebebebebebe");
 23 |         expect(proxy.name).toBe("FixedProxy");
 24 |         expect(proxy.toString()).toBe("FixedProxy");
 25 |     });
 26 | 
 27 |     test('EIP-1167 Proxy: Uniswap v1', async () => {
 28 |         // const address = "0x09cabec1ead1c0ba254b09efb3ee13841712be14";
 29 |         const bytecode = "0x3660006000376110006000366000732157a7894439191e520825fe9399ab8655e0f7085af41558576110006000f3";
 30 |         const want = "0x2157a7894439191e520825fe9399ab8655e0f708";
 31 |         const program = disasm(bytecode);
 32 |         expect(program.proxies[0]).toBeInstanceOf(proxies.FixedProxyResolver);
 33 |         const proxy = program.proxies[0] as proxies.FixedProxyResolver;
 34 |         expect(proxy.resolvedAddress).toBe(want);
 35 |     });
 36 | 
 37 |     test('Solady Minimal Proxy: CWIA', async () => {
 38 |         // https://github.com/Vectorized/solady/blob/main/src/utils/LibClone.sol
 39 |         const bytecode = "0x36602c57343d527f9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff593da1005b363d3d373d3d3d3d610016806062363936013d73bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb5af43d3d93803e606057fd5bf3e127ce638293fa123be79c25782a5652581db2340016";
 40 |         const program = disasm(bytecode);
 41 |         expect(program.proxies[0]).toBeInstanceOf(proxies.FixedProxyResolver);
 42 |         const proxy = program.proxies[0] as proxies.FixedProxyResolver;
 43 |         const want = "0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";
 44 |         expect(proxy.resolvedAddress).toBe(want);
 45 |     });
 46 | 
 47 |     test('SequenceWallet Proxy', async () => {
 48 |         // Gas-optimized version of EIP-1167
 49 |         // https://github.com/0xsequence/wallet-contracts/blob/master/contracts/Wallet.sol
 50 |         const bytecode = "0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3";
 51 |         const program = disasm(bytecode);
 52 |         expect(program.proxies[0]).toBeInstanceOf(proxies.SequenceWalletProxyResolver);
 53 |     });
 54 | 
 55 |     test('Gnosis Safe Proxy Factory', async () => {
 56 |         // https://eips.ethereum.org/EIPS/eip-1167
 57 |         const bytecode = "0x608060405273ffffffffffffffffffffffffffffffffffffffff600054167fa619486e0000000000000000000000000000000000000000000000000000000060003514156050578060005260206000f35b3660008037600080366000845af43d6000803e60008114156070573d6000fd5b3d6000f3fea265627a7a72315820d8a00dc4fe6bf675a9d7416fc2d00bb3433362aa8186b750f76c4027269667ff64736f6c634300050e0032";
 58 | 
 59 |         const program = disasm(bytecode);
 60 |         expect(program.proxies[0]).toBeInstanceOf(proxies.GnosisSafeProxyResolver);
 61 |         expect(program.proxies[0].name).toBe("GnosisSafeProxy");
 62 |     });
 63 | 
 64 |     test('ZeppelinOS Proxy', async () => {
 65 |         const bytecode = ZEPPELINOS_USDC;
 66 |         const program = disasm(bytecode);
 67 |         expect(program.proxies[0]).toBeInstanceOf(proxies.ZeppelinOSProxyResolver);
 68 |     });
 69 | 
 70 |     // TODO: Make this work
 71 |     test.skip('EIP-1967 Proxy: Wanderwing', async () => {
 72 |         const bytecode = WANDERWING;
 73 |         const program = disasm(bytecode);
 74 |         expect(program.proxies[0]).toBeInstanceOf(proxies.EIP1967ProxyResolver);
 75 |     });
 76 | });
 77 | 
 78 | describe('known proxy resolving', () => {
 79 |     online_test('Safe: Proxy Factory 1.1.1', async ({ provider }) => {
 80 |         const address = "0x655a9e6b044d6b62f393f9990ec3ea877e966e18";
 81 |         // Need to call masterCopy() or getStorageAt for 0th slot
 82 |         const resolver = new proxies.GnosisSafeProxyResolver();
 83 |         const got = await resolver.resolve(provider, address);
 84 |         const want = "0x34cfac646f301356faa8b21e94227e3583fe3f5f";
 85 |         expect(got).toEqual(want);
 86 |     });
 87 | 
 88 |     online_test('EIP-1967 Proxy: Aztec TransparentUpgradeableProxy', async ({ provider }) => {
 89 |         const address = "0xff1f2b4adb9df6fc8eafecdcbf96a2b351680455";
 90 |         const resolver = new proxies.EIP1967ProxyResolver();
 91 |         const got = await resolver.resolve(provider, address);
 92 |         const wantImplementation = "0x7d657ddcf7e2a5fd118dc8a6ddc3dc308adc2728";
 93 | 
 94 |         expect(got).toEqual(wantImplementation);
 95 |     });
 96 | 
 97 |     online_test('EIP-1967 Proxy: NFTX', async ({ provider }) => {
 98 |         const address = "0x3E135c3E981fAe3383A5aE0d323860a34CfAB893";
 99 |         const resolver = new proxies.EIP1967ProxyResolver();
100 |         const got = await resolver.resolve(provider, address);
101 |         const wantImplementation = "0xccb1cfc9caa2b73a82ad23a9b3219da900485880";
102 | 
103 |         expect(got).toEqual(wantImplementation);
104 |     });
105 | 
106 |     online_test('EIP-2535 Diamond Proxy: ZkSync Era', async ({ provider }) => {
107 |         // More diamond proxies, if we need sometime: https://gist.github.com/banteg/74fa02c5457f2141bba11dd431fc2b57
108 | 
109 |         const address = "0x32400084C286CF3E17e7B677ea9583e60a000324";
110 |         const resolver = new proxies.DiamondProxyResolver();
111 |         const selector = "0x6e9960c3";  // function getAdmin() returns (address)
112 |         const got = await resolver.resolve(provider, address, selector);
113 | 
114 |         // ZkSync updates their proxies so it's annoying to maintain the desired mapping
115 |         expect(got).not.toEqual("0x0000000000000000000000000000000000000000");
116 |     });
117 | 
118 |     online_test('EIP-2535 Diamond Proxy: Read facets from internal storage', async ({ provider }) => {
119 |         const address = "0x32400084C286CF3E17e7B677ea9583e60a000324";
120 |         const resolver = new proxies.DiamondProxyResolver();
121 |         const got = await resolver.selectors(provider, address);
122 | 
123 |         expect(got).to.not.equal([]);
124 |     });
125 | 
126 |     // FIXME: Is there one on mainnet? Seems they're all on polygon
127 |     //online_test('SequenceWallet Proxy', async() => {
128 |     //});
129 | 
130 |     cached_test('LayerrProxy on Sepolia', async({ withCache }) => {
131 |         // For issue #139: https://github.com/shazow/whatsabi/issues/139
132 |         const provider = makeProvider("https://ethereum-sepolia-rpc.publicnode.com");
133 |         const address = "0x2f4eeccbe817e2b9f66e8123387aa81bae08dfec";
134 |         const code = await withCache(
135 |             `${address}_code`,
136 |             async () => {
137 |                 return await provider.getCode(address)
138 |             },
139 |         );
140 | 
141 |         const program = disasm(code);
142 |         const resolver = program.proxies[0];
143 |         const got = await resolver.resolve(provider, address);
144 |         const wantImplementation = "0x0000000000f7a60f1c88f317f369e3d8679c6689";
145 | 
146 |         expect(got).toEqual(wantImplementation);
147 |     });
148 | });
149 | 
150 | 
151 | describe('contract proxy resolving', () => {
152 |     cached_test('Create2Beacon Proxy', async ({ provider, withCache }) => {
153 |         const address = "0x581acd618ba7ef6d3585242423867adc09e8ed60";
154 |         const code = await withCache(
155 |             `${address}_code`,
156 |             async () => {
157 |                 return await provider.getCode(address)
158 |             },
159 |         )
160 | 
161 |         const program = disasm(code);
162 |         expect(program.proxies.length).toEqual(1);
163 | 
164 |         const resolver = program.proxies[0];
165 |         const got = await resolver.resolve(provider, address);
166 | 
167 |         const wantImplementation = "0xaddc3e67a500f7037cd622b11df291a6351bfb64";
168 |         expect(got).toEqual(wantImplementation);
169 |     });
170 | 
171 |     cached_test('Vyper Minimal Proxy', async ({ provider, withCache }) => {
172 |         const address = "0x2d5d4869381c4fce34789bc1d38acce747e295ae";
173 |         const code = await withCache(
174 |             `${address}_code`,
175 |             async () => {
176 |                 return await provider.getCode(address)
177 |             },
178 |         )
179 | 
180 |         const program = disasm(code);
181 |         expect(program.proxies.length).toEqual(1);
182 | 
183 |         const resolver = program.proxies[0];
184 |         const got = await resolver.resolve(provider, address);
185 | 
186 |         const wantImplementation = "0x9c13e225ae007731caa49fd17a41379ab1a489f4";
187 |         expect(got).toEqual(wantImplementation);
188 |     });
189 | });
190 | 
191 | 
192 | describe('proxy internal slot reading', () => {
193 |     test('addSlotOffset', async () => {
194 |         const slot = "0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131b";
195 |         const got = addSlotOffset(slot, 2);
196 | 
197 |         expect(got).to.equal("0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131d");
198 |     });
199 | 
200 |     test('joinSlot', async() => {
201 |         const got = joinSlot(["0xf3acf6a03ea4a914b78ec788624b25cec37c14a4", "0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c"]);
202 |         const want = "0x42983d3cf213719a972df53d14775d9ca74cc01b862f850a60cf959f26ffe0a2";
203 |         expect(got).toEqual(want);
204 |     });
205 | 
206 |     online_test('ReadArray: Addresses and Selectors', async ({ provider }) => {
207 |         const address = "0x32400084C286CF3E17e7B677ea9583e60a000324";
208 |         const facetsOffset = addSlotOffset(proxies.slots.DIAMOND_STORAGE, 2); // Facets live in the 3rd slot (0-indexed)
209 | 
210 |         const addressWidth = 20; // Addresses are 20 bytes
211 |         const facets = await readArray(provider, address, facetsOffset, addressWidth);
212 |         expect(facets.length).to.not.equal(0);
213 | 
214 |         // Read selectors
215 |         const storageStart = addSlotOffset(proxies.slots.DIAMOND_STORAGE, 1); // facetToSelector in 2nd slot
216 |         const facetAddress = "0x" + facets[0];
217 |         const facetToSelectorSlot = joinSlot([facetAddress, storageStart]);
218 |         const selectorWidth = 4;
219 |         const got = await readArray(provider, address, facetToSelectorSlot, selectorWidth);
220 |         expect(got.length).to.not.equal(0);
221 |     });
222 | });
223 | 
224 | 
225 | describe('multiple proxy resolving', () => {
226 |     cached_test('resolve WeightedRateSetCollectionPool', async ({ withCache, provider }) => {
227 |         const address = "0x56C5Aef1296d004707475c8440f540DdA409b53D";
228 |         const code = await withCache(
229 |             `${address}_code`,
230 |             async () => {
231 |                 return await provider.getCode(address)
232 |             },
233 |         );
234 |         const program = disasm(code);
235 | 
236 |         expect(program.proxies.length).to.be.equal(4);
237 |     });
238 | 
239 | });
240 | 


--------------------------------------------------------------------------------
/src/__tests__/selectors.test.ts:
--------------------------------------------------------------------------------
 1 | import { expect, test } from 'vitest';
 2 | 
 3 | import { selectorsFromBytecode } from '../index';
 4 | 
 5 | import { cached_test, describe_cached } from "./env";
 6 | 
 7 | 
 8 | cached_test('cached online: selectorsFromBytecode for Uniswap v2 Router', async ({ provider, withCache }) => {
 9 |   const address = "0x7a250d5630b4cf539739df2c5dacb4c659f2488d";
10 | 
11 |   const code = await withCache(
12 |     `${address}_code`,
13 |     async () => {
14 |       return await provider.getCode(address)
15 |     },
16 |   )
17 | 
18 |   const r = selectorsFromBytecode(code);
19 |   r.sort();
20 | 
21 |   expect(r).toStrictEqual(['0x02751cec', '0x054d50d4', '0x18cbafe5', '0x1f00ca74', '0x2195995c', '0x38ed1739', '0x4a25d94a', '0x5b0d5984', '0x5c11d795', '0x791ac947', '0x7ff36ab5', '0x85f8c259', '0x8803dbee', '0xad5c4648', '0xad615dec', '0xaf2979eb', '0xb6f9de95', '0xbaa2abde', '0xc45a0155', '0xd06ca61f', '0xded9382a', '0xe8e33700', '0xf305d719', '0xfb3bdb41']);
22 | });
23 | 
24 | cached_test('cached online: selectorsFromBytecode for 0x00000000 method', async ({ provider, withCache }) => {
25 |   // Via https://twitter.com/smithbot_eth/status/1576368841072201728
26 |   // Note: This contract self-destructs and reinits with new code occasionally,
27 |   // so this test could break. Would be nice to have an immutable contract with
28 |   // a zero selector.
29 |   const address = "0x000000000000Df8c944e775BDe7Af50300999283";
30 | 
31 |   const code = await withCache(
32 |     `${address}_code`,
33 |     async () => {
34 |       return await provider.getCode(address)
35 |     },
36 |   )
37 | 
38 |   const r = selectorsFromBytecode(code);
39 |   expect(r).toEqual(expect.arrayContaining(['0x00000000', '0xf04f2707']))
40 | });
41 | 
42 | describe_cached("detecting zero selector", async ({ provider, withCache}) => {
43 |   // Check positive cases
44 |   test.each([
45 |     {address: "0x000000000000Df8c944e775BDe7Af50300999283"},
46 |   ])("check presence: $address", async ({address}) => {
47 |     const code = await withCache(`${address}_code`, provider.getCode.bind(provider, address))
48 |     const r = selectorsFromBytecode(code);
49 |     expect(r).toEqual(expect.arrayContaining(['0x00000000']))
50 |   });
51 | 
52 |   // Check negative cases
53 |   test.each([
54 |     {address: "0x99aa182ed0e2b6c47132e95686d2c73cdeff307f"},
55 |     {address: "0xb1116d0a09f06d3e22a264c0c233d80e93abec10"},
56 |     {address: "0xb60e36e2d67a34b4eae678cad779e281e4c6d58c"},
57 |   ])("check absence: $address", async ({address}) => {
58 |     const code = await withCache(`${address}_code`, provider.getCode.bind(provider, address))
59 |     const r = selectorsFromBytecode(code);
60 |     expect(r).to.not.equal(expect.arrayContaining(['0x00000000']))
61 |   });
62 | });
63 | 
64 | cached_test('cached online: selectorsFromBytecode that had 0x000000000 false positives', async({ provider, withCache }) => {
65 | });
66 | 


--------------------------------------------------------------------------------
/src/__tests__/util.test.ts:
--------------------------------------------------------------------------------
 1 | import { expect, test, describe } from 'vitest';
 2 | 
 3 | import { ethers } from "ethers";
 4 | 
 5 | import { hexToBytes, bytesToHex, keccak256 } from "../utils";
 6 | 
 7 | describe('Utils', () => {
 8 |   test.each([
 9 |     new Uint8Array([0, 1, 2, 3]),
10 |     new Uint8Array([42, 69, 255]),
11 |     new Uint8Array([255]),
12 |     new Uint8Array([255, 255]),
13 |     new Uint8Array([0, 255, 0, 255]),
14 |   ])("bytesToHex %s", (bytes) => {
15 |     expect(bytesToHex(bytes)).toStrictEqual(ethers.hexlify(bytes));
16 |   });
17 | 
18 |   test("bytesToHex padding", () => {
19 |     expect(bytesToHex(new Uint8Array([0]), 20)).toStrictEqual("0x0000000000000000000000000000000000000000");
20 |     expect(bytesToHex(new Uint8Array([255, 255, 255]), 20)).toStrictEqual("0x0000000000000000000000000000000000ffffff");
21 |   });
22 | 
23 | 
24 |   test.each([
25 |     "0x00010203",
26 |     "0x0000102030",
27 |     "0x2a45ff",
28 |     "0xff",
29 |     "0xffff",
30 |     "0x00ff00ff",
31 |   ])("hexToBytes %s", (hex) => {
32 |     expect(hexToBytes(hex)).toStrictEqual(ethers.getBytes(hex));
33 |   });
34 | 
35 |   test.each([
36 |     "0x00010203",
37 |     "0xffff",
38 |     "0xffff0000111122223333444455556666777788889999aaaabbbbccccddddeeee",
39 |     new Uint8Array([0, 1, 2, 3]),
40 |     new Uint8Array([255, 0, 255, 0, 255, 0]),
41 |   ])("keccak256 %s", (hex) => {
42 |     expect(keccak256(hex)).toStrictEqual(ethers.keccak256(hex));
43 |   });
44 | 
45 | });
46 | 
47 | 


--------------------------------------------------------------------------------
/src/_generated-interfaces.ts:
--------------------------------------------------------------------------------
 1 | // Generated using examples/index-interfaces.ts
 2 | export default {
 3 |   "ERC-20": new Set(["18160ddd", "70a08231", "a9059cbb", "dd62ed3e", "095ea7b3", "23b872dd"]),
 4 |   "ERC-165": new Set(["01ffc9a7"]),
 5 |   "ERC-721": new Set(["70a08231", "6352211e", "b88d4fde", "42842e0e", "23b872dd", "095ea7b3", "a22cb465", "081812fc", "e985e9c5"]),
 6 |   "ERC-777": new Set(["06fdde03", "95d89b41", "556f0dc7", "18160ddd", "70a08231", "9bd9bbc6", "fe9d9303", "d95b6371", "959b8c3f", "fad8b32a", "06e48538", "62ad1b83", "fc673c4f"]),
 7 |   "ERC-1155": new Set(["00fdd58e", "4e1273f4", "a22cb465", "e985e9c5", "996cd54f", "680fd525"]),
 8 |   "Ownable": new Set(["8da5cb5b", "715018a6", "f2fde38b"]),
 9 |   "Multicall": new Set(["ac9650d8"]),
10 |   "ISafe": new Set(["6a761202", "934f3a11", "f698da25", "affed0e0"]),
11 |   "EIP-1271": new Set(["1626ba7e"]),
12 | };
13 | 


--------------------------------------------------------------------------------
/src/abi.ts:
--------------------------------------------------------------------------------
  1 | export type StateMutability = "nonpayable"|"payable"|"view"|"pure";
  2 | 
  3 | export type ABIFunction = {
  4 |     type: "function"; // TODO: constructor, receive, fallback
  5 |     selector: string;
  6 |     name?: string;
  7 |     outputs?: ABIOutput[];
  8 |     inputs?: ABIInput[];
  9 |     sig?: string;
 10 |     sigAlts?: string[];
 11 |     payable?: boolean;
 12 |     stateMutability?: StateMutability;
 13 | };
 14 | 
 15 | export type ABIEvent = {
 16 |     type: "event",
 17 |     hash: string,
 18 |     name?: string;
 19 |     sig?: string;
 20 |     sigAlts?: string[];
 21 |     // TODO: ...
 22 | };
 23 | 
 24 | export type ABIInput = {
 25 |     type: string;
 26 |     name: string;
 27 |     length?: number;
 28 |     components?: ABIInOut[];
 29 | }
 30 | 
 31 | export type ABIOutput = {
 32 |     type: string;
 33 |     name: string;
 34 |     components?: ABIInOut[];
 35 | }
 36 | 
 37 | export type ABIInOut = ABIInput|ABIOutput;
 38 | 
 39 | export type ABI = (ABIFunction|ABIEvent)[];
 40 | 
 41 | /**
 42 |  * Fills tuple component's empty names in an ABI with generated names
 43 |  *
 44 |  * @example
 45 |  * Input: {
 46 |  *   "type": "function",
 47 |  *   "selector": "0x95d376d7",
 48 |  *   "payable": false,
 49 |  *   "stateMutability": "payable",
 50 |  *   "inputs": [
 51 |  *     {
 52 |  *       "type": "tuple",
 53 |  *       "name": "",
 54 |  *       "components": [
 55 |  *         { "type": "uint32", "name": "" },
 56 |  *         { "type": "bytes", "name": "" },
 57 |  *         { "type": "bytes32", "name": "" },
 58 |  *         { "type": "uint64", "name": "" },
 59 |  *         { "type": "address", "name": "" }
 60 |  *       ]
 61 |  *     },
 62 |  *     { "type": "bytes", "name": "" }
 63 |  *   ],
 64 |  *   "sig": "assignJob((uint32,bytes,bytes32,uint64,address),bytes)",
 65 |  *   "name": "assignJob",
 66 |  *   "constant": false
 67 |  * }
 68 |  *
 69 |  * Output: {
 70 |  *   "type": "function",
 71 |  *   "selector": "0x95d376d7",
 72 |  *   "payable": false,
 73 |  *   "stateMutability": "payable",
 74 |  *   "inputs": [
 75 |  *     {
 76 |  *       "type": "tuple",
 77 |  *       "name": "",
 78 |  *       "components": [
 79 |  *         { "type": "uint32", "name": "_param0" },
 80 |  *         { "type": "bytes", "name": "_param1" },
 81 |  *         { "type": "bytes32", "name": "_param2" },
 82 |  *         { "type": "uint64", "name": "_param3" },
 83 |  *         { "type": "address", "name": "_param4" }
 84 |  *       ]
 85 |  *     },
 86 |  *     { "type": "bytes", "name": "" }
 87 |  *   ],
 88 |  *   "sig": "assignJob((uint32,bytes,bytes32,uint64,address),bytes)",
 89 |  *   "name": "assignJob",
 90 |  *   "constant": false
 91 |  * }
 92 |  *
 93 |  * @param abi The ABI to process
 94 |  * @returns A new ABI with tuple component names filled
 95 |  */
 96 | export function fillEmptyNames(abi: ABI): ABI {
 97 |   function processComponents(components: ABIInOut[]): void {
 98 |     components.forEach((component, index) => {
 99 |       component.name ||= `_param${index}`;
100 |       if (isTupleType(component.type) && component.components) {
101 |         processComponents(component.components);
102 |       }
103 |     });
104 |   }
105 | 
106 |   const result: ABI = abi.map((item) => {
107 |     if (item.type === "function") {
108 |       const func: ABIFunction = { ...item };
109 |       func.inputs?.forEach((input) => {
110 |         if (isTupleType(input.type) && input.components) {
111 |           processComponents(input.components);
112 |         }
113 |       });
114 |       func.outputs?.forEach((output) => {
115 |         if (isTupleType(output.type) && output.components) {
116 |           processComponents(output.components);
117 |         }
118 |       });
119 |       return func;
120 |     }
121 |     return item;
122 |   });
123 | 
124 |   return result;
125 | }
126 | 
127 | /**
128 |  * Checks if a type is a tuple type (e.g. "tuple", "tuple[]", "tuple[2]")
129 |  * @param type type to check
130 |  * @returns true if the type is a tuple type
131 |  */
132 | function isTupleType(type: string): boolean {
133 |   return type.startsWith("tuple");
134 | }


--------------------------------------------------------------------------------
/src/auto.ts:
--------------------------------------------------------------------------------
  1 | import * as AbiFunction from 'ox/AbiFunction';
  2 | import * as AbiEvent from 'ox/AbiEvent';
  3 | 
  4 | import type { AnyProvider } from "./providers.js";
  5 | import type { ABI, ABIFunction } from "./abi.js";
  6 | import { type ProxyResolver, DiamondProxyResolver } from "./proxies.js";
  7 | import type { ABILoader, SignatureLookup, ContractResult } from "./loaders.js";
  8 | import * as errors from "./errors.js";
  9 | 
 10 | import { CompatibleProvider } from "./providers.js";
 11 | import { defaultABILoader, defaultSignatureLookup } from "./loaders.js";
 12 | import { abiFromBytecode, disasm } from "./disasm.js";
 13 | import { MultiABILoader } from "./loaders.js";
 14 | 
 15 | 
 16 | /// Magic number we use to determine whether a proxy is reasonably a destination contract or not.
 17 | /// If it has many SSTORE's then it's probably doing something other than proxying.
 18 | const PROXY_SSTORE_COUNT_MAX = 4;
 19 | 
 20 | function isAddress(address: string) {
 21 |     return address.length === 42 && address.startsWith("0x") && Number(address) >= 0;
 22 | }
 23 | 
 24 | export const defaultConfig = {
 25 |     onProgress: (_: string) => { },
 26 |     onError: (phase: string, err: Error) => { console.error(phase + ":", err); return false; },
 27 | }
 28 | 
 29 | /** AutoloadResult is the return type for the {@link autoload} function. */
 30 | export type AutoloadResult = {
 31 |     address: string,
 32 |     abi: ABI;
 33 | 
 34 |     /** Whether the `abi` is loaded from a verified source */
 35 |     abiLoadedFrom?: ABILoader;
 36 | 
 37 |     /** Full contract metadata result, only included if {@link AutoloadConfig.loadContractResult} is true. */
 38 |     contractResult?: ContractResult;
 39 | 
 40 |     /** List of resolveable proxies detected in the contract */
 41 |     proxies: ProxyResolver[],
 42 | 
 43 |     /**
 44 |      * Follow proxies to next result.
 45 |      * If multiple proxies were detected, some reasonable ordering of attempts will be made.
 46 |      * Note: Some proxies operate relative to a specific selector (such as DiamondProxy facets), in this case we'll need to specify a selector that we care about.
 47 |      */
 48 |     followProxies?: (selector?: string) => Promise<AutoloadResult>,
 49 | 
 50 |     /**
 51 |      * Set to true when a CREATE or CREATE2 opcode is present in the bytecode.
 52 |      * This means that some of the results could have been mistaken from the embedded contract that gets created by the factory.
 53 |      * For example, we can have a non-proxy contract which creates a proxy contract on call. WhatsABI may not yet be able to distinguish them reliably.
 54 |      *
 55 |      * @experimental
 56 |      */
 57 |     isFactory?: boolean;
 58 | 
 59 |     /** Set to true if the address has deployed code */
 60 |     hasCode: boolean;
 61 | }
 62 | 
 63 | 
 64 | /**
 65 |  * AutoloadConfig specifies the configuration inputs for the {@link autoload} function.
 66 |  **/
 67 | export type AutoloadConfig = {
 68 |     /** @group Required */
 69 |     provider: AnyProvider;
 70 | 
 71 |     /** @group Loaders */
 72 |     abiLoader?: ABILoader | false;
 73 |     /** @group Loaders */
 74 |     signatureLookup?: SignatureLookup | false;
 75 | 
 76 |     /** Hooks: */
 77 | 
 78 |     /**
 79 |      * Called during various phases: resolveName, getCode, abiLoader, signatureLookup, followProxies
 80 |      * @group Hooks
 81 |      */
 82 |     onProgress?: (phase: string, ...args: any[]) => void;
 83 | 
 84 |     /**
 85 |      * Called during any encountered errors during a given phase
 86 |      * @group Hooks
 87 |      */
 88 |     onError?: (phase: string, error: Error) => boolean | void; // Return true-y to abort, undefined/false-y to continue
 89 | 
 90 |     /**
 91 |      * Called to resolve invalid addresses, uses provider's built-in resolver otherwise
 92 |      * @group Hooks
 93 |      */
 94 |     addressResolver?: (name: string) => Promise<string>;
 95 | 
 96 |     /** Settings: */
 97 | 
 98 |     /**
 99 |      * Enable following proxies automagically if *reasonable*. Return the final result.
100 |      *
101 |      * Some caveats:
102 |      * - Proxies that are relative to a specific selector (such as DiamondProxies) will not be followed.
103 |      * - Contracts that are not primarily proxies will not be followed. Current heuristic is containing at most 5 SSTORE instructions. (See Issue #173)
104 |      *
105 |      * @group Settings
106 |      */
107 |     followProxies?: boolean;
108 | 
109 | 
110 |     /**
111 |      * Load full contract metadata result, include it in {@link AutoloadResult.contractResult} if successful.
112 |      *
113 |      * This changes the behaviour of autoload to use {@link ABILoader.getContract} instead of {@link ABILoader.loadABI},
114 |      * which returns a larger superset result including all of the available verified contract metadata.
115 |      */
116 |     loadContractResult?: boolean;
117 | 
118 |     /**
119 |      * Enable pulling additional metadata from WhatsABI's static analysis which may be unreliable.
120 |      * For now, this is primarily for event topics.
121 |      *
122 |      * @group Settings
123 |      * @experimental
124 |      */
125 |     enableExperimentalMetadata?: boolean;
126 | }
127 | 
128 | /**
129 |  * autoload is a convenience helper for doing All The Things to load an ABI of a contract address, including resolving proxies.
130 |  * @param address - The address of the contract to load
131 |  * @param config - the {@link AutoloadConfig} object
132 |  * @example
133 |  * ```typescript
134 |  * import { ethers } from "ethers";
135 |  * import { whatsabi } from "@shazow/whatsabi";
136 |  *
137 |  * const provider = ethers.getDefaultProvider(); // substitute with your fav provider
138 |  * const address = "0x00000000006c3852cbEf3e08E8dF289169EdE581"; // Or your fav contract address
139 |  *
140 |  * // Quick-start:
141 |  *
142 |  * const result = await whatsabi.autoload(address, { provider });
143 |  * console.log(result.abi);
144 |  * // -> [ ... ]
145 |  * ```
146 |  * @example
147 |  * See {@link AutoloadConfig} for additional features that can be enabled.
148 |  * ```typescript
149 |  * const result = await whatsabi.autoload(address, {
150 |  *   provider,
151 |  *   followProxies: true,
152 |  *   loadContractResult: true, // Load full contract metadata (slower)
153 |  *   enableExperimentalMetadata: true, // Include less reliable static analysis results (e.g. event topics)
154 |  *   // and more! See AutoloadConfig for all the options.
155 |  * });
156 |  * ```
157 |  */
158 | export async function autoload(address: string, config: AutoloadConfig): Promise<AutoloadResult> {
159 |     if (config === undefined) {
160 |         throw new errors.AutoloadError("config is undefined, must include 'provider'");
161 |     }
162 | 
163 |     const onProgress = config.onProgress || defaultConfig.onProgress;
164 |     const onError = config.onError || defaultConfig.onError;
165 |     const provider = CompatibleProvider(config.provider);
166 | 
167 |     const result: AutoloadResult = {
168 |         address,
169 |         abi: [],
170 |         proxies: [],
171 |         hasCode: false,
172 |     };
173 | 
174 |     let abiLoader = config.abiLoader;
175 |     if (abiLoader === undefined) abiLoader = defaultABILoader;
176 | 
177 |     if (!isAddress(address)) {
178 |         onProgress("resolveName", { address });
179 |         if (config.addressResolver) {
180 |             address = await config.addressResolver(address);
181 |         } else {
182 |             try {
183 |                 address = await provider.getAddress(address);
184 |             } catch (err) {
185 |                 throw new errors.AutoloadError(`Failed to resolve ENS address using provider.getAddress, try supplying your own resolver in AutoloadConfig by specifying addressResolver`, {
186 |                     context: { address },
187 |                     cause: err as Error,
188 |                 });
189 |             }
190 |         }
191 |     }
192 | 
193 |     // Load code, we need to disasm to find proxies
194 |     onProgress("getCode", { address });
195 |     let bytecode: string;
196 |     try {
197 |         bytecode = await provider.getCode(address);
198 |     } catch (err) {
199 |         throw new errors.AutoloadError(`Failed to fetch contract code due to provider error: ${err instanceof Error ? err.message : String(err)}`,
200 |             {
201 |                 context: { address },
202 |                 cause: err as Error,
203 |             },
204 |         );
205 |     }
206 |     if (!bytecode || bytecode === "0x") return result; // Must be an EOA
207 |     result.hasCode = true;
208 | 
209 |     const program = disasm(bytecode);
210 | 
211 |     result.proxies = program.proxies; // FIXME: Sort them in some reasonable way
212 |     result.isFactory = program.isFactory;
213 | 
214 |     // Mapping of address-to-valid-selectors. Non-empty mapping values will prune ABIs to the selectors before returning.
215 |     // This is mainly to support multiple proxies and diamond proxies.
216 |     const facets: Record<string, string[]> = {
217 |         [address]: [],
218 |     };
219 | 
220 |     if (result.proxies.length === 1 && result.proxies[0] instanceof DiamondProxyResolver) {
221 |         // TODO: Respect config.followProxies, see https://github.com/shazow/whatsabi/issues/132
222 |         onProgress("loadDiamondFacets", { address });
223 |         const diamondProxy = result.proxies[0] as DiamondProxyResolver;
224 |         const f = await diamondProxy.facets(provider, address);
225 |         Object.assign(facets, f);
226 | 
227 |     } else if (result.proxies.length > 0 && program.sstoreCount <= PROXY_SSTORE_COUNT_MAX) {
228 |         result.followProxies = async function(selector?: string): Promise<AutoloadResult> {
229 |             // This attempts to follow the first proxy that resolves successfully.
230 |             // FIXME: If there are multiple proxies, should we attempt to merge them somehow?
231 |             for (const resolver of result.proxies) {
232 |                 onProgress("followProxies", { resolver: resolver, address });
233 |                 const resolved = await resolver.resolve(provider, address, selector);
234 |                 if (resolved !== undefined) return await autoload(resolved, config);
235 |             }
236 |             onError("followProxies", new Error("failed to resolve proxy"));
237 |             return result;
238 |         };
239 | 
240 |         if (config.followProxies) {
241 |             return await result.followProxies();
242 |         }
243 |     }
244 | 
245 |     if (abiLoader) {
246 |         // Attempt to load the ABI from a contract database, if exists
247 |         onProgress("abiLoader", { address, facets: Object.keys(facets) });
248 |         const loader = abiLoader;
249 | 
250 |         let abiLoadedFrom = loader;
251 |         let originalOnLoad;
252 |         if (loader instanceof MultiABILoader) {
253 |             // This is a workaround for avoiding to change the loadABI signature, we can remove it if we use getContract instead.
254 |             const onLoad = (loader: ABILoader) => {
255 |                 abiLoadedFrom = loader;
256 |             }
257 |             originalOnLoad = loader.onLoad;
258 |             if (!loader.onLoad) loader.onLoad = onLoad;
259 |             else {
260 |                 // Just in case someone uses this feature, let's wrap it to include both. Not ideal... Is there a better way here?
261 |                 const original = loader.onLoad;
262 |                 loader.onLoad = (loader: ABILoader) => { original(loader); onLoad(loader); };
263 |             }
264 |         }
265 | 
266 |         try {
267 |             if (config.loadContractResult) {
268 |                 const contractResult = await loader.getContract(address);
269 |                 if (contractResult && Array.isArray(contractResult.abi) && contractResult.abi.length > 0) {
270 |                     // We assume that a verified contract ABI contains all of the relevant resolved proxy functions
271 |                     // so we don't need to mess with resolving facets and can return immediately.
272 |                     result.contractResult = contractResult;
273 |                     result.abi = contractResult.abi;
274 |                     result.abiLoadedFrom = contractResult.loader;
275 |                     return result;
276 |                 }
277 |             } else {
278 |                 // Load ABIs of all available facets and merge
279 |                 const addresses = Object.keys(facets);
280 |                 const promises = addresses.map(addr => loader.loadABI(addr));
281 |                 const results = await Promise.all(promises);
282 |                 const abis = Object.fromEntries(results.map((abi, i) => {
283 |                     return [addresses[i], abi];
284 |                 }));
285 |                 result.abi = pruneFacets(facets, abis);
286 |                 if (result.abi.length > 0) {
287 |                     result.abiLoadedFrom = abiLoadedFrom;
288 |                     return result;
289 |                 }
290 |             }
291 |         } catch (error: any) {
292 |             // TODO: Catch useful errors
293 |             if (onError("abiLoader", error) === true) return result;
294 |         } finally {
295 |             if (loader instanceof MultiABILoader) {
296 |                 loader.onLoad = originalOnLoad;
297 |             }
298 |         }
299 |     }
300 | 
301 |     // Load from code
302 |     onProgress("abiFromBytecode", { address });
303 |     result.abi = abiFromBytecode(program);
304 | 
305 |     if (!config.enableExperimentalMetadata) {
306 |         result.abi = stripUnreliableABI(result.abi);
307 |     }
308 | 
309 |     // Add any extra ABIs we found from facets
310 |     result.abi.push(...Object.values(facets).flat().map(selector => {
311 |         return {
312 |             type: "function",
313 |             selector,
314 |         } as ABIFunction;
315 |     }));
316 | 
317 |     let signatureLookup = config.signatureLookup;
318 |     if (signatureLookup === undefined) signatureLookup = defaultSignatureLookup;
319 |     if (!signatureLookup) return result; // Bail
320 | 
321 |     // Load signatures from a database
322 |     onProgress("signatureLookup", { abiItems: result.abi.length });
323 | 
324 |     let promises: Promise<void>[] = [];
325 | 
326 |     for (const a of result.abi) {
327 |         if (a.type === "function") {
328 |             promises.push(signatureLookup.loadFunctions(a.selector).then((r) => {
329 |                 if (r.length >= 1) {
330 |                     a.sig = r[0];
331 | 
332 |                     // Extract as much metadata as it can from the signature
333 |                     const extracted : any = AbiFunction.from("function " + a.sig, { prepare: false });
334 |                     if (extracted.outputs.length === 0) {
335 |                         // Outputs not included in signature databases -_- (unless something changed)
336 |                         // Let whatsabi keep its best guess, if any.
337 |                         delete (extracted.outputs);
338 |                     }
339 | 
340 |                     Object.assign(a, extracted)
341 |                 }
342 |                 if (r.length > 1) a.sigAlts = r.slice(1);
343 |             }));
344 |         } else if (a.type === "event") {
345 |             promises.push(signatureLookup.loadEvents(a.hash).then((r) => {
346 |                 if (r.length >= 1) {
347 |                     a.sig = r[0];
348 | 
349 |                     // Extract as much metadata as it can from the signature
350 |                     Object.assign(a, AbiEvent.from("function " + a.sig));
351 |                 }
352 |                 if (r.length > 1) a.sigAlts = r.slice(1);
353 |             }));
354 |         }
355 |     }
356 | 
357 |     // Aggregate signatureLookup promises and their errors, if any
358 |     const promiseResults = await Promise.allSettled(promises);
359 |     const rejectedPromises = promiseResults.filter(
360 |         (r) => r.status === "rejected",
361 |     ) as PromiseRejectedResult[];
362 | 
363 |     if (rejectedPromises.length > 0) {
364 |         const cause =
365 |             rejectedPromises.length === 1
366 |                 ? rejectedPromises[0].reason
367 |                 : new AggregateError(rejectedPromises.map((r) => r.reason));
368 |         throw new errors.AutoloadError(
369 |             `Failed to fetch signatures due to loader error: ${cause.message}`,
370 |             {
371 |                 context: { address },
372 |                 cause,
373 |             },
374 |         );
375 |     }
376 | 
377 |     return result;
378 | }
379 | 
380 | function stripUnreliableABI(abi: ABI): ABI {
381 |     const r: ABI = [];
382 |     for (const a of abi) {
383 |         if (a.type !== "function") continue;
384 |         r.push({
385 |             type: "function",
386 |             selector: a.selector,
387 |         });
388 |     }
389 |     return r;
390 | }
391 | 
392 | function pruneFacets(facets: Record<string, string[]>, abis: Record<string, ABI>): ABI {
393 |     const r: ABI = [];
394 |     for (const [addr, abi] of Object.entries(abis)) {
395 |         const allowSelectors = new Set(facets[addr]);
396 |         if (allowSelectors.size === 0) {
397 |             // Skip pruning if the mapping is empty
398 |             r.push(...abi);
399 |             continue;
400 |         }
401 |         for (let a of abi) {
402 |             if (a.type !== "function") {
403 |                 r.push(a);
404 |                 continue;
405 |             }
406 |             a = a as ABIFunction;
407 |             let selector = a.selector;
408 |             if (selector === undefined && a.name) {
409 |                 selector = AbiFunction.getSelector(a as AbiFunction.AbiFunction);
410 |             }
411 |             if (allowSelectors.has(selector)) {
412 |                 r.push(a);
413 |             }
414 |         }
415 |     }
416 |     return r;
417 | }
418 | 


--------------------------------------------------------------------------------
/src/errors.ts:
--------------------------------------------------------------------------------
 1 | export class WhatsABIError extends Error {
 2 |     override name = 'WhatsABIError';
 3 | 
 4 |     // Some variables included from the context scope of the error, for debugging
 5 |     context?: Record<string, any>;
 6 | 
 7 |     constructor(message: string, args: { context?: Record<string, any>, cause?: Error } = {}) {
 8 |         super(message, { cause: args.cause } as ErrorOptions);
 9 | 
10 |         this.context = args.context;
11 |     }
12 | }
13 | 
14 | export class AutoloadError extends WhatsABIError {
15 |     override name = 'AutoloadError';
16 | }
17 | 
18 | export class LoaderError extends WhatsABIError {
19 |     override name = 'LoaderError';
20 | }
21 | 
22 | export class ProviderError extends WhatsABIError {
23 |     override name = 'ProviderError';
24 | }
25 | 


--------------------------------------------------------------------------------
/src/index.ts:
--------------------------------------------------------------------------------
1 | import * as whatsabi from "./whatsabi.js";
2 | 
3 | export { whatsabi };
4 | 
5 | export * from "./whatsabi.js";
6 | 


--------------------------------------------------------------------------------
/src/interfaces.ts:
--------------------------------------------------------------------------------
 1 | import * as AbiFunction from 'ox/AbiFunction';
 2 | 
 3 | import defaultKnownInterfaces from './_generated-interfaces.js';
 4 | 
 5 | export { defaultKnownInterfaces };
 6 | 
 7 | /// KnownInterfaces is a mapping from interface names to lists of function signatures that belong to that interface.
 8 | export type KnownInterfaces = Record<string, Array<string>>;
 9 | 
10 | /// IndexedInterfaces is an optimized mapping of interface names to sorted selectors.
11 | // NOTE: The definition of this type may change to improve efficiency, please use helpers like createInterfaceIndex to produce it.
12 | export type IndexedInterfaces = Record<string, Set<string>>;
13 | 
14 | /** Given a lookup of known interfaces, produce a lookup index to use with {@link abiToInterfaces}.
15 |  * @example
16 |  * ```ts
17 |  * const myInterfaceIndex = whatsabi.interfaces.createInterfaceIndex(
18 |  *   Object.assign({},
19 |  *     // Include defaults?
20 |  *     whatsabi.interfaces.defaultKnownInterfaces,
21 |  *     // Our special secret interface we want to detect
22 |  *     {
23 |  *       "MyInterface": [ "function Foo() returns (uint256)", "function Bar()" ],
24 |  *     },
25 |  *   ),
26 |  * );
27 |  * 
28 |  * const detectedInterfaces = whatsabi.interfaces.abiToInterfaces(abi, myInterfaceIndex);
29 |  * ```
30 |  */
31 | export function createInterfaceIndex(known: KnownInterfaces): IndexedInterfaces {
32 |     const r : IndexedInterfaces = {};
33 |     for (const [name, signatures] of Object.entries(known)) {
34 |         const selectors = signatures.map(sig => AbiFunction.getSelector(sig).slice(2));
35 |         if (selectors.length === 0) continue;
36 |         r[name] = new Set(selectors)
37 |     }
38 |     return r;
39 | }
40 | 
41 | /** Given a list of selectors, return a mapping of interfaces it implements to a list of present function signatures that belong to it.
42 |  * @param {string[]} abiOrSelectors - ABI or a list of selectors or signatures to match against.
43 |  * @param {KnownInterfaces?} knownInterfaces - A mapping of known interfaces to function signatures that belong to them. Use {@link createInterfaceIndex} to produce your own, or omit to use {@link defaultKnownInterfaces}.
44 |  * @returns {string[]} A list of interfaces that the given selectors implement.
45 |  * @example
46 |  * ```ts
47 |  * const result = await whatsabi.autoload(address, { provider });
48 |  * const detectedInterfaces = whatsabi.interfaces.abiToInterfaces(result.abi);
49 |  * ```
50 |  */
51 | export function abiToInterfaces(abiOrSelectors: any[], knownInterfaces?: IndexedInterfaces): string[] {
52 |     const r: string[] = [];
53 |     if (abiOrSelectors.length === 0) return r;
54 |     if (!knownInterfaces) {
55 |         knownInterfaces = defaultKnownInterfaces;
56 |     }
57 |     const selectorSet = new Set(abiOrSelectors.map(s => {
58 |         if (s.length === 8) return s;
59 |         if (s.length === 10) return s.slice(2);
60 |         return AbiFunction.getSelector(s).slice(2);
61 |     }));
62 |     for (const [name, interfaceSet] of Object.entries(knownInterfaces)) {
63 |         // Find interfaces where we have all the selectors.
64 |         if (isSupersetOf(selectorSet, interfaceSet)) {
65 |             r.push(name);
66 |         }
67 |     }
68 |     return r;
69 | }
70 | 
71 | // TODO: Replace this with native Set.isSupersetOf once available
72 | function isSupersetOf<T>(a: Set<T>, b: Set<T>): boolean {
73 |     for (const elem of b) {
74 |         if (!a.has(elem)) {
75 |             return false;
76 |         }
77 |     }
78 |     return true;
79 | }
80 | 


--------------------------------------------------------------------------------
/src/internal/debug.ts:
--------------------------------------------------------------------------------
 1 | import { mnemonics, isPush }  from "../opcodes.js";
 2 | import type { OpCode }  from "../opcodes.js";
 3 | import { BytecodeIter } from "../disasm.js";
 4 | import { bytesToHex } from "../utils.js";
 5 | 
 6 | // Debug helper:
 7 | 
 8 | const hexpads = "0x0000";
 9 | 
10 | export function BytecodeIterString(code : BytecodeIter): string {
11 |     const step = code.step();
12 |     const pos = code.pos();
13 |     let hexpos = bytesToHex(pos);
14 |     if (hexpos.length < hexpads.length) hexpos = hexpads.slice(0, hexpos.length - hexpads.length) + hexpos.slice(2);
15 |     const inst = code.at(pos);
16 |     const value = isPush(inst) ? bytesToHex(code.valueAt(pos)) : "";
17 |     const name = mnemonics[inst] || bytesToHex(inst);
18 | 
19 |     return `${String(step).padStart(6, " ")}\t${hexpos}\t${name}\t${value}`
20 | }
21 | 
22 | export type bytecodeToStringConfig = {
23 |     startPos?: number,
24 |     stopPos?: number,
25 |     highlightPos?: number,
26 |     boundaryPos?: number,
27 |     opcodeLookup?: { [key: OpCode]: string },
28 | };
29 | 
30 | export function* bytecodeToString(
31 |     bytecode: string, 
32 |     config?: bytecodeToStringConfig,
33 | ) {
34 |     const code = new BytecodeIter(bytecode);
35 | 
36 |     if (config === undefined) config = {};
37 |     let { startPos, stopPos, highlightPos, boundaryPos, opcodeLookup } = config;
38 |     if (!opcodeLookup) opcodeLookup = mnemonics;
39 | 
40 |     while (code.hasMore()) {
41 |         code.next();
42 |         const pos = code.pos();
43 | 
44 |         if (startPos && pos < startPos) continue;
45 |         if (stopPos && pos > stopPos) break;
46 |         if (boundaryPos === pos) {
47 |             // const line = bytecode.slice(2 + pos * 2); // pos is byte offset, bytecode is hex string
48 |             const line = bytesToHex(code.bytecode.slice(pos));
49 |             yield line;
50 |             break;
51 |         }
52 | 
53 |         const highlight = (highlightPos === pos) ? " <--" : "";
54 |         const line = BytecodeIterString(code) + highlight;
55 |         const done : boolean = yield line;
56 |         if (done) break;
57 |     }
58 | }
59 | 


--------------------------------------------------------------------------------
/src/internal/filecache.ts:
--------------------------------------------------------------------------------
 1 | import * as fs from 'fs';
 2 | import { Console } from "console";
 3 | 
 4 | const CACHE_DIR = process.env["CACHE_DIR"] || ".cache";
 5 | const logger = new Console(process.stderr);
 6 | 
 7 | export type Cache = {
 8 |   (cacheKey: string, cacheGetter: () => Promise<any>): Promise<any>;
 9 | };
10 | 
11 | export const withCache : Cache = async function(
12 |   cacheKey: string,
13 |   cacheGetter: () => Promise<any>,
14 | ): Promise<any> {
15 |   // Check if cache exists
16 |   const cachePath = `${CACHE_DIR}/${encodeURIComponent(cacheKey)}`;
17 |   if (fs.existsSync(cachePath)) {
18 |     logger.debug("withCache: Using cached value:", cachePath);
19 |     const val = JSON.parse(fs.readFileSync(cachePath, 'utf8'));
20 |     return val;
21 |   }
22 | 
23 |   const val = await cacheGetter();
24 |   if (val === undefined) throw "withCache: undefined value from cacheGetter";
25 | 
26 |   // Save it
27 |   if (!fs.existsSync(CACHE_DIR)) {
28 |     fs.mkdirSync(CACHE_DIR);
29 |   }
30 | 
31 |   logger.debug("withCache: Saving test cache:", cachePath);
32 |   fs.writeFileSync(cachePath, JSON.stringify(val));
33 | 
34 |   return val;
35 | }
36 | 


--------------------------------------------------------------------------------
/src/opcodes.ts:
--------------------------------------------------------------------------------
  1 | export type OpCode = number;
  2 | 
  3 | // Some opcodes we care about, doesn't need to be a complete list
  4 | export const opcodes: Readonly<{ [key: string]: OpCode }> = Object.freeze({
  5 |   STOP: 0x00,
  6 |   ADD: 0x01,
  7 |   MUL: 0x02,
  8 |   SUB: 0x03,
  9 |   DIV: 0x04,
 10 |   SDIV: 0x05,
 11 |   MOD: 0x06,
 12 |   SMOD: 0x07,
 13 |   ADDMOD: 0x08,
 14 |   MULMOD: 0x09,
 15 |   EXP: 0x0a,
 16 |   SIGNEXTEND: 0x0b,
 17 |   LT: 0x10,
 18 |   GT: 0x11,
 19 |   SLT: 0x12,
 20 |   SGT: 0x13,
 21 |   EQ: 0x14,
 22 |   ISZERO: 0x15,
 23 |   AND: 0x16,
 24 |   OR: 0x17,
 25 |   XOR: 0x18,
 26 |   NOT: 0x19,
 27 |   BYTE: 0x1a,
 28 |   SHL: 0x1b,
 29 |   SHR: 0x1c,
 30 |   SAR: 0x1d,
 31 |   SHA3: 0x20,
 32 |   ADDRESS: 0x30,
 33 |   BALANCE: 0x31,
 34 |   ORIGIN: 0x32,
 35 |   CALLER: 0x33,
 36 |   CALLVALUE: 0x34,
 37 |   CALLDATALOAD: 0x35,
 38 |   CALLDATASIZE: 0x36,
 39 |   CALLDATACOPY: 0x37,
 40 |   CODESIZE: 0x38,
 41 |   CODECOPY: 0x39,
 42 |   GASPRICE: 0x3a,
 43 |   EXTCODESIZE: 0x3b,
 44 |   EXTCODECOPY: 0x3c,
 45 |   RETURNDATASIZE: 0x3d,
 46 |   RETURNDATACOPY: 0x3e,
 47 |   EXTCODEHASH: 0x3f,
 48 |   BLOCKHASH: 0x40,
 49 |   COINBASE: 0x41,
 50 |   TIMESTAMP: 0x42,
 51 |   NUMBER: 0x43,
 52 |   DIFFICULTY: 0x44,
 53 |   GASLIMIT: 0x45,
 54 |   CHAINID: 0x46,
 55 |   SELFBALANCE: 0x47,
 56 |   POP: 0x50,
 57 |   MLOAD: 0x51,
 58 |   MSTORE: 0x52,
 59 |   MSTORE8: 0x53,
 60 |   SLOAD: 0x54,
 61 |   SSTORE: 0x55,
 62 |   JUMP: 0x56,
 63 |   JUMPI: 0x57,
 64 |   PC: 0x58,
 65 |   MSIZE: 0x59,
 66 |   GAS: 0x5a,
 67 |   JUMPDEST: 0x5b,
 68 |   PUSH0: 0x5f,
 69 |   PUSH1: 0x60,
 70 |   PUSH2: 0x61,
 71 |   PUSH3: 0x62,
 72 |   PUSH4: 0x63,
 73 |   PUSH5: 0x64,
 74 |   PUSH6: 0x65,
 75 |   PUSH7: 0x66,
 76 |   PUSH8: 0x67,
 77 |   PUSH9: 0x68,
 78 |   PUSH10: 0x69,
 79 |   PUSH11: 0x6a,
 80 |   PUSH12: 0x6b,
 81 |   PUSH13: 0x6c,
 82 |   PUSH14: 0x6d,
 83 |   PUSH15: 0x6e,
 84 |   PUSH16: 0x6f,
 85 |   PUSH17: 0x70,
 86 |   PUSH18: 0x71,
 87 |   PUSH19: 0x72,
 88 |   PUSH20: 0x73,
 89 |   PUSH21: 0x74,
 90 |   PUSH22: 0x75,
 91 |   PUSH23: 0x76,
 92 |   PUSH24: 0x77,
 93 |   PUSH25: 0x78,
 94 |   PUSH26: 0x79,
 95 |   PUSH27: 0x7a,
 96 |   PUSH28: 0x7b,
 97 |   PUSH29: 0x7c,
 98 |   PUSH30: 0x7d,
 99 |   PUSH31: 0x7e,
100 |   PUSH32: 0x7f,
101 |   DUP1: 0x80,
102 |   DUP2: 0x81,
103 |   DUP3: 0x82,
104 |   DUP4: 0x83,
105 |   DUP5: 0x84,
106 |   DUP6: 0x85,
107 |   DUP7: 0x86,
108 |   DUP8: 0x87,
109 |   DUP9: 0x88,
110 |   DUP10: 0x89,
111 |   DUP11: 0x8a,
112 |   DUP12: 0x8b,
113 |   DUP13: 0x8c,
114 |   DUP14: 0x8d,
115 |   DUP15: 0x8e,
116 |   DUP16: 0x8f,
117 |   SWAP1: 0x90,
118 |   SWAP2: 0x91,
119 |   SWAP3: 0x92,
120 |   SWAP4: 0x93,
121 |   SWAP5: 0x94,
122 |   SWAP6: 0x95,
123 |   SWAP7: 0x96,
124 |   SWAP8: 0x97,
125 |   SWAP9: 0x98,
126 |   SWAP10: 0x99,
127 |   SWAP11: 0x9a,
128 |   SWAP12: 0x9b,
129 |   SWAP13: 0x9c,
130 |   SWAP14: 0x9d,
131 |   SWAP15: 0x9e,
132 |   SWAP16: 0x9f,
133 |   LOG0: 0xa0,
134 |   LOG1: 0xa1,
135 |   LOG2: 0xa2,
136 |   LOG3: 0xa3,
137 |   LOG4: 0xa4,
138 |   CREATE: 0xf0,
139 |   CALL: 0xf1,
140 |   CALLCODE: 0xf2,
141 |   RETURN: 0xf3,
142 |   DELEGATECALL: 0xf4,
143 |   CREATE2: 0xf5,
144 |   STATICCALL: 0xfa,
145 |   REVERT: 0xfd,
146 |   INVALID: 0xfe,
147 |   SUICIDE: 0xff,
148 | } as const);
149 | 
150 | export const mnemonics: Readonly<{ [key: OpCode]: string }> = Object.freeze(
151 |   Object.fromEntries(
152 |     Object.entries(opcodes).map(([k, v]) => [v, k])
153 |   )
154 | );
155 | 
156 | // Return PUSHN width of N if PUSH instruction, otherwise 0
157 | export function pushWidth(op: OpCode): number {
158 |     if (op < opcodes.PUSH1 || op > opcodes.PUSH32) return 0;
159 |     return op - opcodes.PUSH1 + 1;
160 | }
161 | 
162 | export function isPush(op: OpCode): boolean {
163 |     return !(op < opcodes.PUSH1 || op > opcodes.PUSH32);
164 | }
165 | 
166 | export function isDup(op: OpCode): boolean {
167 |     return !(op < opcodes.DUP1 || op > opcodes.DUP16);
168 | }
169 | 
170 | export function isLog(op: OpCode): boolean {
171 |     return op >= opcodes.LOG1 && op <= opcodes.LOG4;
172 | }
173 | 
174 | export function isSwap(op: OpCode): boolean {
175 |     return op >= opcodes.SWAP1 && op <= opcodes.SWAP16;
176 | }
177 | 
178 | export function isHalt(op: OpCode): boolean {
179 |     return op === opcodes.STOP || op === opcodes.RETURN || op >= opcodes.REVERT; // includes opcodes.SUICIDE, opcodes.INVALID
180 | }
181 | 
182 | export function isCompare(op: OpCode): boolean {
183 |     // LT, GT, LTE, GTE, EQ
184 |     return !(op < 0x10 || op > 0x14)
185 | }
186 | 
187 | export function stackPush(op: OpCode): number {
188 |     return (isSwap(op) || isLog(op) || noStackPush.has(op)) ? 0 : 1;
189 | }
190 | 
191 | export function stackPop(op: OpCode): number {
192 |     return hasStackArgs[op] || 0;
193 | }
194 | 
195 | // Partial set of ops that don't push to stack (not including log and swap)
196 | const noStackPush = new Set<OpCode>([
197 |     opcodes.STOP,
198 |     opcodes.CALLDATACOPY,
199 |     opcodes.CODECOPY,
200 |     opcodes.EXTCODECOPY,
201 |     opcodes.RETURNDATACOPY,
202 |     opcodes.POP,
203 |     opcodes.MSTORE,
204 |     opcodes.MSTORE8,
205 |     opcodes.SSTORE,
206 |     opcodes.JUMP,
207 |     opcodes.JUMPI,
208 |     opcodes.JUMPDEST,
209 |     opcodes.RETURN,
210 |     opcodes.REVERT,
211 |     opcodes.INVALID,
212 |     opcodes.SUICIDE,
213 | ]);
214 | 
215 | const hasStackArgs : Readonly<{ [key: OpCode]: number }> = Object.freeze({
216 |     [opcodes.ADD]: 2,
217 |     [opcodes.MUL]: 2,
218 |     [opcodes.SUB]: 2,
219 |     [opcodes.DIV]: 2,
220 |     [opcodes.SDIV]: 2,
221 |     [opcodes.MOD]: 2,
222 |     [opcodes.SMOD]: 2,
223 |     [opcodes.ADDMOD]: 3,
224 |     [opcodes.MULMOD]: 3,
225 |     [opcodes.EXP]: 2,
226 |     [opcodes.SIGNEXTEND]: 2,
227 |     [opcodes.LT]: 2,
228 |     [opcodes.GT]: 2,
229 |     [opcodes.SLT]: 2,
230 |     [opcodes.SGT]: 2,
231 |     [opcodes.EQ]: 2,
232 |     [opcodes.ISZERO]: 1,
233 |     [opcodes.AND]: 2,
234 |     [opcodes.OR]: 2,
235 |     [opcodes.XOR]: 2,
236 |     [opcodes.NOT]: 1,
237 |     [opcodes.BYTE]: 2,
238 |     [opcodes.SHL]: 2,
239 |     [opcodes.SHR]: 2,
240 |     [opcodes.SAR]: 2,
241 |     [opcodes.SHA3]: 2,
242 |     [opcodes.BALANCE]: 1,
243 |     [opcodes.CALLDATALOAD]: 1,
244 |     [opcodes.CALLDATACOPY]: 3,
245 |     [opcodes.CODECOPY]: 3,
246 |     [opcodes.EXTCODESIZE]: 1,
247 |     [opcodes.EXTCODECOPY]: 4,
248 |     [opcodes.RETURNDATACOPY]: 3,
249 |     [opcodes.EXTCODEHASH]: 1,
250 |     [opcodes.BLOCKHASH]: 1,
251 |     [opcodes.POP]: 1,
252 |     [opcodes.MLOAD]: 1,
253 |     [opcodes.MSTORE]: 2,
254 |     [opcodes.MSTORE8]: 2,
255 |     [opcodes.SLOAD]: 1,
256 |     [opcodes.SSTORE]: 2,
257 |     [opcodes.JUMP]: 1,
258 |     [opcodes.JUMPI]: 2,
259 |     [opcodes.LOG0]: 2,
260 |     [opcodes.LOG1]: 3,
261 |     [opcodes.LOG2]: 4,
262 |     [opcodes.LOG3]: 5,
263 |     [opcodes.LOG4]: 6,
264 |     [opcodes.CREATE]: 3,
265 |     [opcodes.CALL]: 7,
266 |     [opcodes.CALLCODE]: 7,
267 |     [opcodes.RETURN]: 2,
268 |     [opcodes.DELEGATECALL]: 6,
269 |     [opcodes.CREATE2]: 4,
270 |     [opcodes.STATICCALL]: 6,
271 |     [opcodes.REVERT]: 2,
272 |     [opcodes.SUICIDE]: 1,
273 | })
274 | 
275 | 


--------------------------------------------------------------------------------
/src/providers.ts:
--------------------------------------------------------------------------------
  1 | import { bytesToHex } from "./utils.js";
  2 | import * as errors from "./errors.js";
  3 | 
  4 | 
  5 | export interface StorageProvider {
  6 |     getStorageAt(address: string, slot: number | string): Promise<string>
  7 | }
  8 | 
  9 | export interface CallProvider {
 10 |     call(transaction: { to: string, data: string }): Promise<string>;
 11 | }
 12 | 
 13 | export interface CodeProvider {
 14 |     getCode(address: string): Promise<string>;
 15 | }
 16 | 
 17 | export interface ENSProvider {
 18 |     getAddress(name: string): Promise<string>;
 19 | }
 20 | 
 21 | export interface Provider extends StorageProvider, CallProvider, CodeProvider, ENSProvider {};
 22 | 
 23 | 
 24 | export interface AnyProvider { }; // TODO: Can we narrow this more?
 25 | 
 26 | 
 27 | interface EIP1193RequestArguments {
 28 |   readonly method: string;
 29 |   readonly params?: readonly unknown[] | object;
 30 | }
 31 | 
 32 | interface EIP1193 {
 33 |     request(args: EIP1193RequestArguments): Promise<unknown>;
 34 | }
 35 | 
 36 | 
 37 | // Abstract away web3 provider inconsistencies
 38 | 
 39 | function isCompatibleProvider(provider: any): boolean {
 40 |     // FIXME: Is there a better way to use the TypeScript type system to do this?
 41 |     // `provider isinstance Provider` does not work because Provider is an interface, not a class. Should it be?
 42 |     return (
 43 |         typeof provider.getStorageAt === "function" &&
 44 |         typeof provider.call === "function" &&
 45 |         typeof provider.getCode === "function" &&
 46 |         typeof provider.getAddress === "function"
 47 |     );
 48 | }
 49 | 
 50 | export function CompatibleProvider(provider: any): Provider {
 51 |     if (isCompatibleProvider(provider)) {
 52 |         // Already compatible, avoid rewrapping it
 53 |         return provider;
 54 |     }
 55 |     if (typeof provider.getAddress === "function") {
 56 |         return new HighLevelProvider(provider);
 57 |     }
 58 |     if (typeof provider.resolveName === "function") {
 59 |         // Ethers-like
 60 |         if (typeof provider.send === "function") {
 61 |             return new EthersProvider(provider);
 62 |         }
 63 |         // Probably FallbackProvider or a different custom wrapper?
 64 |         // Need to use higher-level functions.
 65 |         return new HighLevelProvider(provider);
 66 |     }
 67 |     if (typeof provider.getEnsAddress === "function") {
 68 |         return new ViemProvider(provider);
 69 |     }
 70 |     if (typeof provider?.eth?.ens?.getAddress === "function") {
 71 |         return new Web3Provider(provider);
 72 |     }
 73 |     if (typeof provider.request === "function") {
 74 |         // Might be a viem transport, or something else
 75 |         return new RPCProvider(provider);
 76 |     }
 77 | 
 78 |     throw new errors.ProviderError("Unsupported provider, please open an issue: https://github.com/shazow/whatsabi/issues", {
 79 |         context: { provider },
 80 |     });
 81 | }
 82 | 
 83 | /**
 84 |  * Wrap an existing provider into one that will return a fixed getCode result for items defined in codeCache.
 85 |  * The cache is treated as read-only, it will not be updated. Mainly used to avoid an extra RPC call when we already have the bytcode.
 86 |  *
 87 |  * For more advanced behaviours, consider copying this code and modifying it to your needs.
 88 |  *
 89 |  * @param provider - Any existing provider
 90 |  * @param codeCache - Object containing address => code mappings
 91 |  * @returns {Provider} - Provider that will return a fixed getCode result for items defined in codeCache.
 92 |  * @example
 93 |  * ```ts
 94 |  * const address = "0x0000000000000000000000000000000000000001";
 95 |  * const bytecode = "0x6001600101"
 96 |  * const cachedProvider = WithCachedCode(provider, {
 97 |  *   [address]: bytecode,
 98 |  * });
 99 |  * const code = await cachedProvider.getCode(address);
100 |  * console.log(code); // "0x6001600101"
101 |  * ```
102 |  */
103 | export function WithCachedCode(provider: AnyProvider, codeCache: Record<string, string>): Provider {
104 |     const compatibleProvider = CompatibleProvider(provider);
105 |     const p = Object.create(compatibleProvider); // use compatibleProvider as the prototype
106 |     p.getCode = async function getCode(address: string): Promise<string> {
107 |         if (codeCache[address]) {
108 |             return codeCache[address];
109 |         }
110 |         return await compatibleProvider.getCode(address);
111 |     };
112 |     return p;
113 | }
114 | 
115 | 
116 | // RPCPRovider thesis is: let's stop trying to adapt to every RPC wrapper library's high-level functions
117 | // and instead have a discovery for the lowest-level RPC call function that we can use directly.
118 | // At least whenever possible. Higher-level functionality like getAddress is still tricky.
119 | class RPCProvider implements Provider, EIP1193 {
120 |     provider: any;
121 | 
122 |     constructor(provider: any) {
123 |         this.provider = provider;
124 |     }
125 | 
126 |     // Based on EIP-1193
127 |     request(req: {method: string, params?: object|Array<unknown>}): Promise<any> {
128 |         return this.provider.request(req);
129 |     }
130 | 
131 |     getStorageAt(address: string, slot: number | string): Promise<string> {
132 |         if (typeof slot === "number") {
133 |             slot = bytesToHex(slot);
134 |         }
135 |         return this.request({method: "eth_getStorageAt", params: [address, slot, "latest"]});
136 |     }
137 | 
138 |     call(transaction: { to: string, data: string }): Promise<string> {
139 |         return this.request({ method: "eth_call", params: [
140 |             {
141 |                 from: "0x0000000000000000000000000000000000000001",
142 |                 to: transaction.to,
143 |                 data: transaction.data,
144 |             },
145 |             "latest"
146 |         ]});
147 |     }
148 | 
149 |     getCode(address: string): Promise<string> {
150 |         return this.request({ method: "eth_getCode", params: [address, "latest"]});
151 |     }
152 | 
153 |     getAddress(name: string): Promise<string> {
154 |         throw new MissingENSProviderError("Provider does not implement getAddress, required to resolve ENS", {
155 |             context: {name, provider: this.provider},
156 |         });
157 |     }
158 | }
159 | 
160 | export class MissingENSProviderError extends errors.ProviderError { };
161 | 
162 | // HighLevelProvider is used for high-level providers like ethers' FallbackProvider
163 | class HighLevelProvider implements Provider {
164 |     provider: any;
165 | 
166 |     constructor(provider: any) {
167 |         this.provider = provider;
168 |     }
169 | 
170 |     getStorageAt(address: string, slot: number | string): Promise<string> {
171 |         if ("getStorageAt" in this.provider) {
172 |             return this.provider.getStorageAt(address, slot);
173 |         }
174 |         return this.provider.getStorage(address, slot);
175 |     }
176 | 
177 |     call(transaction: { to: string, data: string }): Promise<string> {
178 |         return this.provider.call(transaction);
179 |     }
180 | 
181 |     getCode(address: string): Promise<string> {
182 |         return this.provider.getCode(address);
183 |     }
184 | 
185 |     getAddress(name: string): Promise<string> {
186 |         return this.provider.getAddress(name);
187 |     }
188 | }
189 | 
190 | type JSONRPCResponse = {
191 |     result?: string,
192 |     error?: {
193 |         id: number,
194 |         message: string,
195 |     };
196 | };
197 | 
198 | class Web3Provider extends RPCProvider {
199 |     request({method, params}: EIP1193RequestArguments): Promise<any> {
200 |         // this.provider is the web3 instance, we need web3.provider
201 |         const r = this.provider.currentProvider.request({ method, params, "jsonrpc": "2.0", id: "1" });
202 |         return r.then((resp: JSONRPCResponse) => {
203 |             if (resp.result) return resp.result;
204 |             else if (resp.error) throw new Web3ProviderError(resp.error.message, {
205 |                 context: { method, params, resp },
206 |             });
207 |             return resp;
208 |         });
209 |     }
210 | 
211 |     getAddress(name: string): Promise<string> {
212 |         return this.provider.eth.ens.getAddress(name)
213 |     }
214 | }
215 | 
216 | export class Web3ProviderError extends errors.ProviderError { };
217 | 
218 | 
219 | class EthersProvider extends RPCProvider {
220 |     request(args: EIP1193RequestArguments): Promise<any> {
221 |         // Fun fact: Before 2020, EIP1193 draft had used .send(method, params) instead of .request({method, params})
222 |         return this.provider.send(args.method, args.params);
223 |     }
224 | 
225 |     getAddress(name: string): Promise<string> {
226 |         return this.provider.resolveName(name);
227 |     }
228 | }
229 | 
230 | class ViemProvider extends RPCProvider {
231 |     request(args: EIP1193RequestArguments): Promise<any> {
232 |         return this.provider.transport.request(args);
233 |     }
234 | 
235 |     getAddress(name: string): Promise<string> {
236 |         return this.provider.getEnsAddress({ name });
237 |     }
238 | }
239 | 


--------------------------------------------------------------------------------
/src/proxies.ts:
--------------------------------------------------------------------------------
  1 | /**
  2 |  * @module proxies
  3 |  * This module contains code to resolve a variety of types of proxies.
  4 |  *
  5 |  * The resolvers are detected and configured by whatsabi.autoload(...).
  6 |  *
  7 |  * If you already know which proxy it is and how it's configured, then the resolvers could be used manually too.
  8 |  *
  9 |  * @example
 10 |  * Using WhatsABI to only resolve proxies with a known bytecode:
 11 |  * ```ts
 12 |  * const address = "0x...";
 13 |  *
 14 |  * // Skip this and use the regular `provider` if you don't already have the bytecode or don't care about saving an RPC call. :)
 15 |  * const bytecode = "0x..."; // Already loaded from somewhere
 16 |  * const cachedCodeProvider = whatsabi.providers.WithCachedCode(provider, {
 17 |  *   [address]: bytecode,
 18 |  * });
 19 |  *
 20 |  * const result = whatsabi.autoload(address, {
 21 |  *   provider: cachedCodeProvider,
 22 |  *   abiLoader: false, // Skip ABI loaders
 23 |  *   signatureLookup: false, // Skip looking up selector signatures
 24 |  * })
 25 |  *
 26 |  * if (result.address !== address) console.log(`Resolved proxy: ${address} -> ${result.address}`);
 27 |  * if (result.proxies.length > 0) console.log("Proxies detected:", result.proxies);
 28 |  * // Note that some proxies can only be resolved relative to a selector, like DiamondProxy. These will need to be resolved manually via result.proxies.
 29 |  * ```
 30 |  *
 31 |  * @example
 32 |  * Resolve a DiamondProxy:
 33 |  * ```ts
 34 |  * // Let's say we have a result with a DiamondProxy in it, from the above example
 35 |  * const resolver = result.proxies[0] as whatsabi.proxies.DiamondProxyResolver;
 36 |  * 
 37 |  * // DiamondProxies have different contracts mapped relative to the selector,
 38 |  * // so we must resolve them against a selector.
 39 |  * const selector = "0x6e9960c3";  // function getAdmin() returns (address)
 40 |  *
 41 |  * const implementationAddress = await resolver.resolve(provider, address, selector);
 42 |  * ```
 43 |  *
 44 |  * @example
 45 |  * Get all facets and selectors for a DiamondProxy:
 46 |  * ```ts
 47 |  * // Let's say we have a result with a DiamondProxy in it, from the above example
 48 |  * const diamondResolver = result.proxies[0] as DiamondProxyResolver;
 49 |  * const facets = await diamondResolver.facets(provider, address); // All possible address -> selector[] mappings
 50 |  * ```
 51 |  */
 52 | import type { StorageProvider, CallProvider } from "./providers.js";
 53 | import { addSlotOffset, readArray, joinSlot } from "./slots.js";
 54 | import { addressWithChecksum } from "./utils.js";
 55 | 
 56 | export interface ProxyResolver {
 57 |     readonly name: string;
 58 |     resolve(provider: StorageProvider|CallProvider, address: string, selector?: string): Promise<string>
 59 |     toString(): string,
 60 | }
 61 | 
 62 | 
 63 | // Some helpers:
 64 | 
 65 | 
 66 | const _zeroAddress = "0x0000000000000000000000000000000000000000";
 67 | 
 68 | // Convert 32 byte hex to a 20 byte hex address
 69 | function addressFromPadded(data:string): string {
 70 |     return "0x" + data.slice(data.length - 40);
 71 | }
 72 | 
 73 | // Resolvers:
 74 | 
 75 | export class BaseProxyResolver {
 76 |     name: string;
 77 | 
 78 |     constructor(name?: string) {
 79 |         this.name = name || this.constructor.name;
 80 |     }
 81 | 
 82 |     toString(): string {
 83 |         return this.name;
 84 |     }
 85 | }
 86 | 
 87 | export class GnosisSafeProxyResolver extends BaseProxyResolver implements ProxyResolver {
 88 |     async resolve(provider: StorageProvider, address: string): Promise<string> {
 89 |         const slotPosition = 0; // masterCopy() is always first slot
 90 |         return addressFromPadded(await provider.getStorageAt(address, slotPosition));
 91 |     }
 92 | }
 93 | 
 94 | // 2016-era upgradeable proxy by Nick Johnson
 95 | // https://gist.github.com/Arachnid/4ca9da48d51e23e5cfe0f0e14dd6318f
 96 | export class LegacyUpgradeableProxyResolver extends BaseProxyResolver implements ProxyResolver {
 97 |     async resolve(provider: StorageProvider, address: string): Promise<string> {
 98 |         const slotPosition = 1; // // _dist is in the second slot
 99 |         return addressFromPadded(await provider.getStorageAt(address, slotPosition));
100 |     }
101 | }
102 | 
103 | const EIP1967FallbackSelectors = [
104 |     "0x5c60da1b", // implementation()
105 |     "0xda525716", // childImplementation()
106 |     "0xa619486e", // masterCopy()
107 |     "0xbb82aa5e", // comptrollerImplementation()
108 | ];
109 | 
110 | export class EIP1967ProxyResolver extends BaseProxyResolver implements ProxyResolver {
111 |     override name = "EIP1967Proxy";
112 | 
113 |     async resolve(provider: StorageProvider & CallProvider, address: string): Promise<string> {
114 |         // Is there an implementation defined?
115 |         const implAddr = addressFromPadded(await provider.getStorageAt(address, slots.EIP1967_IMPL));
116 |         if (implAddr !== _zeroAddress) {
117 |             return implAddr;
118 |         }
119 | 
120 |         // Gotta find the fallback...
121 |         const fallbackAddr = addressFromPadded(await provider.getStorageAt(address, slots.EIP1967_BEACON));
122 |         if (fallbackAddr === _zeroAddress) {
123 |             return _zeroAddress;
124 |         }
125 | 
126 |         // Possible optimizations for the future:
127 |         // 1. We could getCode and finding the correct selector using disasm, but maybe not worth it with small number of calls.
128 |         // 2. We could use multicall3 (if available)
129 |         for (const selector of EIP1967FallbackSelectors) {
130 |             try {
131 |                 const addr = addressFromPadded(await provider.call({
132 |                     to: fallbackAddr,
133 |                     data: selector,
134 |                 }));
135 |                 if (addr !== _zeroAddress) return addr;
136 |             } catch (e: any) {
137 |                 if (e.toString().includes("revert")) continue;
138 |                 throw e;
139 |             }
140 |         }
141 |         return _zeroAddress;
142 |     }
143 | }
144 | 
145 | const diamondSelectors = [
146 |     "0xcdffacc6", // Diamond Loupe uses selector "0xcdffacc6": facetAddress(bytes4 _functionSelector)
147 |     "0x0d741577", // Some implementations (OpenZeppelin) use selector "0x0d741577": implementation(bytes4 func)
148 | ];
149 | 
150 | // ERC2535 - Diamond/Facet Proxy
151 | export class DiamondProxyResolver extends BaseProxyResolver implements ProxyResolver {
152 |     override name = "DiamondProxy";
153 | 
154 |     async resolve(provider: StorageProvider & CallProvider, address: string, selector: string): Promise<string> {
155 |         if (!selector) {
156 |             throw "DiamondProxy requires a selector to resolve to a specific facet";
157 |         } else if (selector.startsWith("0x")) {
158 |             selector = selector.slice(2);
159 |         }
160 | 
161 |         // Selectors are considered "strings and byte arrays" so they're "unpadded data" (ie. end-padded) as opposed to start-padded like addresses etc.
162 |         //
163 |         // ethers.utils.defaultAbiCoder.encode(["bytes4", "bytes32"], ["0x" + selector, slots.DIAMOND_STORAGE])
164 |         // keccak256("0x" + selector.padEnd(64, "0") + slots.DIAMOND_STORAGE.slice(2));
165 |         const facetMappingSlot = joinSlot([selector.padEnd(64, "0"), slots.DIAMOND_STORAGE]);
166 | 
167 |         const facet = await provider.getStorageAt(address, facetMappingSlot);
168 | 
169 |         // It's a struct with a few fields, take the right 20 bytes
170 |         const storageAddr = "0x" + facet.slice(facet.length - 40);
171 |         if (storageAddr !== _zeroAddress) {
172 |             return storageAddr;
173 |         }
174 | 
175 |         // Try the selectors are a fallback
176 |         for (const facetSelector of diamondSelectors) {
177 |             try {
178 |                 const addr = addressFromPadded(await provider.call({
179 |                     to: address,
180 |                     data: facetSelector + selector,
181 |                 }));
182 |                 if (addr !== _zeroAddress) return addr;
183 |             } catch (e: any) {
184 |                 if (e.toString().includes("revert")) continue;
185 |                 throw e;
186 |             }
187 |         }
188 |         return _zeroAddress;
189 |     }
190 | 
191 |     // Return the facet-to-selectors mapping
192 |     // Note that this does not respect frozen facet state.
193 |     async facets(provider: StorageProvider, address: string): Promise<Record<string, string[]>> {
194 |         // Would be cool if we could read the private facets storage and return known selectors... let's do it!
195 |         //
196 |         // Shoutout to @banteg for sharing the rest of the owl:
197 |         // - https://twitter.com/shazow/status/1693636008179343598
198 |         // - https://gist.github.com/banteg/0cee21909f7c1baedfa6c3d96ffe94f2
199 | 
200 |         // TODO: Respect frozen facets?
201 |         // let isFrozen = false;
202 |         // if (config && !config.ignoreFrozen) {
203 |         //     const isFrozenOffset = addSlotOffset(storageStart, 3); // isFrozen
204 |         //     const isFrozenWord = await provider.getStorageAt(address, isFrozenOffset);
205 |         //     isFrozen = isFrozenWord.slice(-1) === "1"
206 |         // }
207 |         // ... the rest of the owl :3
208 | 
209 |         // 1. Read the DiamondStorage.facets array
210 |         //
211 |         // struct DiamondStorage {
212 |         //   mapping(bytes4 => SelectorToFacet) selectorToFacet;
213 |         //   mapping(address => FacetToSelectors) facetToSelectors;
214 |         //   address[] facets;
215 |         //   bool isFrozen;
216 |         // }
217 |         const storageStart = slots.DIAMOND_STORAGE;
218 | 
219 |         const facetsOffset = addSlotOffset(storageStart, 2); // Facets live in the 3rd slot (0-indexed)
220 |         const addressWidth = 20; // Addresses are 20 bytes
221 |         const facets = await readArray(provider, address, facetsOffset, addressWidth);
222 | 
223 |         // 2. Read FacetToSelectors.selectors[] via facetToSelectors[address].selectors[]
224 |         //
225 |         // struct FacetToSelectors {
226 |         //     bytes4[] selectors;
227 |         //     uint16 facetPosition;
228 |         // }
229 | 
230 |         const selectorWidth = 4;
231 |         const facetSelectors : Record<string, string[]> = {};
232 |         const slot = addSlotOffset(storageStart, 1); // facetToSelector in 2nd slot
233 |         for (const f of facets) {
234 |             const facet = addressFromPadded(f);
235 |             const facetSelectorsSlot = joinSlot([facet, slot]);
236 |             const selectors = await readArray(provider, address, facetSelectorsSlot, selectorWidth);
237 |             facetSelectors[addressWithChecksum(facet)] = selectors.map(s => "0x" + s);
238 |         }
239 | 
240 |         return facetSelectors;
241 |     }
242 | 
243 |     // Return all of the valid selectors that work on this DiamondProxy.
244 |     // Note that this does not respect frozen facet state.
245 |     async selectors(provider: StorageProvider, address: string): Promise<string[]> {
246 |         // Get values from the mapping
247 |         const f = await this.facets(provider, address);
248 |         return Object.values(f).flat();
249 |     }
250 | }
251 | 
252 | export class ZeppelinOSProxyResolver extends BaseProxyResolver implements ProxyResolver {
253 |     override name = "ZeppelinOSProxy";
254 | 
255 |     async resolve(provider: StorageProvider, address: string): Promise<string> {
256 |         return addressFromPadded(await provider.getStorageAt(address, slots.ZEPPELINOS_IMPL));
257 |     }
258 | }
259 | 
260 | export class PROXIABLEProxyResolver extends BaseProxyResolver implements ProxyResolver {
261 |     override name = "PROXIABLEProxy";
262 | 
263 |     async resolve(provider: StorageProvider, address: string): Promise<string> {
264 |         return addressFromPadded(await provider.getStorageAt(address, slots.PROXIABLE));
265 |     }
266 | }
267 | 
268 | // https://github.com/0xsequence/wallet-contracts/blob/master/contracts/Wallet.sol
269 | // Implementation pointer is stored in slot keyed on the deployed address.
270 | export class SequenceWalletProxyResolver extends BaseProxyResolver implements ProxyResolver {
271 |     override name = "SequenceWalletProxy";
272 | 
273 |     async resolve(provider: StorageProvider, address: string): Promise<string> {
274 |         return addressFromPadded(await provider.getStorageAt(address, address.toLowerCase().slice(2)));
275 |     }
276 | }
277 | 
278 | // FixedProxyResolver is used when we already know the resolved address
279 | // No additional resolving required
280 | // Example: EIP-1167
281 | export class FixedProxyResolver extends BaseProxyResolver implements ProxyResolver {
282 |     override name = "FixedProxy";
283 |     readonly resolvedAddress : string;
284 | 
285 |     constructor(name: string, resolvedAddress: string) {
286 |         super(name);
287 |         this.resolvedAddress = resolvedAddress;
288 |     }
289 | 
290 |     async resolve(provider: StorageProvider, address: string): Promise<string> {
291 |         return this.resolvedAddress;
292 |     }
293 | };
294 | 
295 | 
296 | // Lookups:
297 | 
298 | 
299 | // BYTE32's representing references to known proxy storage slots.
300 | export const slots : Record<string, string> = {
301 |     // EIP-1967: Proxy Storage Slots
302 |     // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)
303 |     EIP1967_IMPL: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
304 | 
305 |     // EIP-1967
306 |     // Beacon slot is a fallback if implementation is not set.
307 |     // bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)).
308 |     // Beacon fallback has selectors:
309 |     // - implementation()
310 |     // - childImplementation()
311 |     // - masterCopy() in Gnosis Safe
312 |     // - comptrollerImplementation() in Compound
313 |     EIP1967_BEACON: "0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50",
314 | 
315 |     // https://github.com/OpenZeppelin/openzeppelin-labs/blob/54ad91472fdd0ac4c34aa97d3a3da45c28245510/initializer_with_sol_editing/contracts/UpgradeabilityProxy.sol
316 |     // bytes32(uint256(keccak256("org.zeppelinos.proxy.implementation")))
317 |     ZEPPELINOS_IMPL: "0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3",
318 | 
319 |     // ERC-1822: Universal Upgradeable Proxy Standard (UUPS)
320 |     // bytes32(uint256(keccak256("PROXIABLE")))
321 |     PROXIABLE: "0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7",
322 | 
323 |     // Gnosis Safe Proxy Factor 1.1.1
324 |     // Not actually a slot, but there's a PUSH32 to the masterCopy() selector
325 |     // masterCopy value lives in the 0th slot on the contract
326 |     GNOSIS_SAFE_SELECTOR: "0xa619486e00000000000000000000000000000000000000000000000000000000",
327 | 
328 |     // Diamond Proxy, as used by ZkSync Era contract
329 |     // https://etherscan.io/address/0x32400084c286cf3e17e7b677ea9583e60a000324#code
330 |     // keccak256("diamond.standard.diamond.storage") - 1;
331 |     DIAMOND_STORAGE: "0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131b",
332 | 
333 |     // EIP-1167 minimal proxy standard
334 |     // Parsed in disasm
335 | }
336 | 
337 | 
338 | export const slotResolvers : Record<string, ProxyResolver> = {
339 |     [slots.EIP1967_IMPL]: new EIP1967ProxyResolver("EIP1967Proxy"),
340 |     [slots.EIP1967_BEACON]: new EIP1967ProxyResolver("EIP1967Proxy"),
341 |     [slots.ZEPPELINOS_IMPL]: new ZeppelinOSProxyResolver("ZeppelinOSProxy"),
342 |     [slots.PROXIABLE]: new PROXIABLEProxyResolver("PROXIABLE"),
343 |     [slots.GNOSIS_SAFE_SELECTOR]: new GnosisSafeProxyResolver("GnosisSafeProxy"),
344 |     [slots.DIAMOND_STORAGE]: new DiamondProxyResolver("DiamondProxy"),
345 | 
346 |     // Not sure why, there's a compiler optimization that adds 2 to the normal slot?
347 |     // Would love to understand this, if people have ideas
348 |     ["0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131d"]: new DiamondProxyResolver("DiamondProxy"),
349 | };
350 | 


--------------------------------------------------------------------------------
/src/selectors.ts:
--------------------------------------------------------------------------------
 1 | import * as AbiItem from 'ox/AbiItem';
 2 | import * as AbiFunction from 'ox/AbiFunction';
 3 | 
 4 | import { disasm } from "./disasm.js";
 5 | 
 6 | // Load function selectors mapping from ABI, parsed using oxlib
 7 | // Mapping is selector hash to signature
 8 | export function selectorsFromABI(abi: any[]): {[key: string]: string} {
 9 |     const r: {[key: string]: string} = {};
10 | 
11 |     for (const el of abi) {
12 |         if (typeof(el) !== "string" && el.type !== "function") continue;
13 |         const f = AbiItem.getSignature(el);
14 |         const selector = AbiFunction.getSelector(el)
15 |         r[selector] = f;
16 |     }
17 | 
18 |     return r;
19 | }
20 | 
21 | // Load function selectors from EVM bytecode by parsing JUMPI instructions
22 | export function selectorsFromBytecode(code: string): string[] {
23 |     const p = disasm(code, { onlyJumpTable: true });
24 |     return Object.keys(p.selectors);
25 | }
26 | 


--------------------------------------------------------------------------------
/src/slots.ts:
--------------------------------------------------------------------------------
 1 | import { keccak256 } from "./utils.js";
 2 | import type { StorageProvider } from "./providers.js";
 3 | 
 4 | 
 5 | export function joinSlot(parts: string[]): string {
 6 |     return keccak256("0x" + parts.map(s => {
 7 |         if (s.startsWith("0x")) {
 8 |             s = s.slice(2);
 9 |         }
10 |         return s.padStart(64, "0");
11 |     }).join(""))
12 | }
13 | 
14 | export function addSlotOffset(slot: string, offset: number): string {
15 |     return "0x" + (BigInt(slot) + BigInt(offset)).toString(16);
16 | }
17 | 
18 | /**
19 |  * Read an array at some slot
20 |  * @param {StorageProvider} provider - Implementation of a provider that can call getStorageAt
21 |  * @param {string} address - Address of the contract storage namespace
22 |  * @param {number|string} pos - Slot position of the array
23 |  * @param {number=} width - Array item size, in bytes
24 |  * @returns {Promise<string[]>} Values of the array at the given slot
25 |  */
26 | export async function readArray(provider: StorageProvider, address: string, pos: number|string, width: number=32): Promise<string[]> {
27 |     // Based on https://gist.github.com/banteg/0cee21909f7c1baedfa6c3d96ffe94f2
28 |     const num = Number(await provider.getStorageAt(address, pos));
29 |     const start = keccak256(pos.toString(16)); // toString(16) does the right thing on strings too (no-op) (:
30 |     const itemsPerWord = Math.floor(32 / width);
31 | 
32 |     const promises : Promise<string>[] = [];
33 |     for (let i=0; i<num; i++) {
34 |         const itemSlot = addSlotOffset(start, Math.floor(i / itemsPerWord));
35 |         promises.push(provider.getStorageAt(address, itemSlot));
36 |     }
37 | 
38 |     const words : string[] = await Promise.all(promises);
39 | 
40 |     return words.map((wordHex: string, i: number) => {
41 |         // TODO: Extract multiple words if they fit in a slot?
42 |         const itemOffset = 2 + 64 - (i % itemsPerWord + 1) * width * 2; // 0x + 2 hex per byte
43 |         return wordHex.slice(itemOffset, itemOffset + width * 2);
44 |     });
45 | }
46 | 


--------------------------------------------------------------------------------
/src/utils.ts:
--------------------------------------------------------------------------------
 1 | // Convert 32 bytes of hex to Uint8Array, undefined for other sizes
 2 | //
 3 | // Borrowed from:
 4 | // https://chat.openai.com/share/ae1e8813-ac3d-4262-89c7-14c462febb34
 5 | export function hexToBytes(hex: string): Uint8Array {
 6 |   if (hex.startsWith("0x")) {
 7 |     hex = hex.slice(2);
 8 |   }
 9 | 
10 |   const length = hex.length;
11 |   if (length % 2 !== 0) {
12 |     throw new Error('hexToBytes: odd input length, must be even: ' + hex);
13 |   }
14 | 
15 |   const r = new Uint8Array(length / 2);
16 | 
17 |   for (let i = 0; i < length; i += 2) {
18 |     const highNibble = parseInt(hex[i], 16);
19 |     const lowNibble = parseInt(hex[i + 1], 16);
20 |     r[i / 2] = (highNibble << 4) | lowNibble;
21 |   }
22 | 
23 |   return r;
24 | }
25 | 
26 | export function bytesToHex(bytes: Uint8Array|Number, padToBytes?: number): string {
27 |   const hex = typeof bytes === 'number' ? bytes.toString(16) : Array.prototype.map.call(bytes, function(n: number) {
28 |     return n.toString(16).padStart(2, "0");
29 |   }).join("");
30 | 
31 |   if (padToBytes) {
32 |     return "0x" + hex.padStart(padToBytes * 2, "0");
33 |   }
34 | 
35 |   return "0x" + hex;
36 | }
37 | 
38 | 
39 | import { keccak_256 } from '@noble/hashes/sha3';
40 | 
41 | export function keccak256(data: Uint8Array|string): string {
42 |   if (typeof data !== "string") {
43 |     return bytesToHex(keccak_256(data));
44 |   }
45 |   if (data.startsWith("0x")) {
46 |     data = hexToBytes(data.slice(2));
47 |   }
48 |   return bytesToHex(keccak_256(data));
49 | }
50 | 
51 | 
52 | export class FetchError extends Error {
53 |   status: number;
54 | 
55 |   constructor(message: string, status: number) {
56 |     super(message);
57 |     this.status = status;
58 |   }
59 | }
60 | 
61 | export async function fetchJSON(url: string): Promise<any> {
62 |   const response = await fetch(url, {
63 |     headers: {
64 |       "Content-Type": "application/json",
65 |     },
66 |   });
67 |   if (!response.ok) {
68 |       throw new FetchError(response.statusText, response.status);
69 |   }
70 |   return response.json();
71 | }
72 | 
73 | 
74 | // Borrowed from ethers.js with minor modifications
75 | // https://github.com/ethers-io/ethers.js/blob/32915634bef5b81c6d9998f4e9ad812ffe721954/src.ts/address/address.ts#L8
76 | // MIT License, copyright Richard Moore
77 | export function addressWithChecksum(address: string): string {
78 |     const chars = address.toLowerCase().substring(2).split("");
79 | 
80 |     const expanded = new Uint8Array(40);
81 |     for (let i = 0; i < 40; i++) {
82 |         expanded[i] = chars[i].charCodeAt(0);
83 |     }
84 | 
85 |     const hashed = keccak_256(expanded);
86 |     for (let i = 0; i < 40; i += 2) {
87 |         if ((hashed[i >> 1] >> 4) >= 8) {
88 |             chars[i] = chars[i].toUpperCase();
89 |         }
90 |         if ((hashed[i >> 1] & 0x0f) >= 8) {
91 |             chars[i + 1] = chars[i + 1].toUpperCase();
92 |         }
93 |     }
94 | 
95 |     return "0x" + chars.join("");
96 | }
97 | 


--------------------------------------------------------------------------------
/src/whatsabi.ts:
--------------------------------------------------------------------------------
 1 | export {
 2 |     selectorsFromABI,
 3 |     selectorsFromBytecode,
 4 | } from "./selectors.js";
 5 | 
 6 | export {
 7 |     BytecodeIter,
 8 |     abiFromBytecode,
 9 | } from "./disasm.js";
10 | 
11 | export {
12 |     autoload,
13 | } from "./auto.js";
14 | 
15 | export type {
16 |     AutoloadResult,
17 |     AutoloadConfig,
18 | } from "./auto.js";
19 | 
20 | import * as loaders from "./loaders.js";
21 | export { loaders };
22 | 
23 | import * as proxies from "./proxies.js";
24 | export { proxies };
25 | 
26 | import * as providers from "./providers.js";
27 | export { providers };
28 | 
29 | import * as abi from "./abi.js";
30 | export { abi };
31 | 
32 | import * as errors from "./errors.js";
33 | export { errors };
34 | 
35 | import * as interfaces from "./interfaces.js";
36 | export { interfaces };
37 | export type {
38 |     KnownInterfaces,
39 |     IndexedInterfaces,
40 | } from "./interfaces.js";
41 | 


--------------------------------------------------------------------------------
/tsconfig.base.json:
--------------------------------------------------------------------------------
 1 | // Reference: https://www.totaltypescript.com/tsconfig-cheat-sheet
 2 | {
 3 |   "compilerOptions": {
 4 |     "outDir": "./lib",
 5 |     "rootDir": "./src",
 6 | 
 7 |     /* Base Options: */
 8 |     "esModuleInterop": true,
 9 |     "skipLibCheck": true,
10 |     "target": "es2022",
11 |     "verbatimModuleSyntax": true,
12 |     "allowJs": true,
13 |     "resolveJsonModule": true,
14 |     "moduleDetection": "force",
15 | 
16 |     /* Strictness */
17 |     "strict": true,
18 |     // TODO: "noUncheckedIndexedAccess": true,
19 | 
20 |     /* If transpiling with TypeScript: */
21 |     "moduleResolution": "NodeNext",
22 |     "module": "NodeNext",
23 |     "sourceMap": true,
24 | 
25 |     /* If your code runs in the DOM: */
26 |     "lib": ["es2022", "dom", "dom.iterable"],
27 | 
28 |     /* If you're building for a library: */
29 |     "declaration": true,
30 | 
31 |     "forceConsistentCasingInFileNames": true,
32 |     "noEmitOnError": true,
33 |     "noFallthroughCasesInSwitch": true,
34 |     "noImplicitAny": true,
35 |     "noImplicitReturns": true,
36 |     "noUnusedLocals": true
37 |   },
38 |   "include": [
39 |     "./src/*.ts"
40 |   ],
41 |   "exclude": [ ]
42 | }
43 | 


--------------------------------------------------------------------------------
/tsconfig.cjs.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "extends": "./tsconfig.base.json",
 3 |   "exclude": [
 4 |     "src/__tests__"
 5 |   ],
 6 |   "compilerOptions": {
 7 |     "verbatimModuleSyntax": false,
 8 |     "removeComments": true,
 9 |     "module": "commonjs",
10 |     "moduleResolution": "node",
11 |     "outDir": "./lib.cjs"
12 |   }
13 | }
14 | 


--------------------------------------------------------------------------------
/tsconfig.esm.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "extends": "./tsconfig.base.json",
 3 |   "exclude": [
 4 |     "src/__tests__"
 5 |   ],
 6 |   "compilerOptions": {
 7 |     "verbatimModuleSyntax": true,
 8 |     "outDir": "./lib.esm"
 9 |   }
10 | }
11 | 


--------------------------------------------------------------------------------
/tsconfig.json:
--------------------------------------------------------------------------------
1 | {
2 |   "extends": "./tsconfig.base.json"
3 | }
4 | 


--------------------------------------------------------------------------------
/tsconfig.types.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "extends": "./tsconfig.base.json",
 3 |   "exclude": [
 4 |     "src/__tests__"
 5 |   ],
 6 |   "compilerOptions": {
 7 |     "declaration": true,
 8 |     "declarationMap": true,
 9 |     "declarationDir": "./lib.types",
10 |     "emitDeclarationOnly": true
11 |   }
12 | }
13 | 


--------------------------------------------------------------------------------
/typedoc.json:
--------------------------------------------------------------------------------
 1 | {
 2 |     "$schema": "https://typedoc.org/schema.json",
 3 |     "out": "./docs",
 4 |     "entryPoints": [
 5 |         "./src/whatsabi.ts"
 6 |     ],
 7 |     "plugin": [
 8 |         "typedoc-plugin-missing-exports"
 9 |     ],
10 |     "excludeNotDocumented": false,
11 |     "categorizeByGroup": true,
12 |     "groupOrder": ["Variables", "Functions", "Required", "*"],
13 |     "gitRevision": "main"
14 | }
15 | 


--------------------------------------------------------------------------------
/vite.config.ts:
--------------------------------------------------------------------------------
1 | import { defineConfig } from 'vitest/config'
2 | 
3 | export default defineConfig({
4 |   test: {
5 |     testTimeout: 15000,
6 |   },
7 | })
8 | 


--------------------------------------------------------------------------------

